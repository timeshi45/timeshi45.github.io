<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机组成与体系结构&#39;</title>
      <link href="/2022/05/07/ji-suan-ji-zu-cheng-yu-ti-xi-jie-gou/"/>
      <url>/2022/05/07/ji-suan-ji-zu-cheng-yu-ti-xi-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Flynn分类法"><a href="#一、Flynn分类法" class="headerlink" title="一、Flynn分类法"></a>一、Flynn分类法</h1><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一种常见的计算机体系结构分类方法，主要有两个分类指标</span><br><span class="line">1. 指令流</span><br><span class="line">2. 数据流</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>体系结构类型</th><th>结构</th><th>关键特性</th><th>代表</th></tr></thead><tbody><tr><td>单指令流单数据流<br>SISD</td><td>控制器：一个<br>处理器：一个<br>主存模块：一个</td><td></td><td>单处理器系统</td></tr><tr><td>单指令流多数据流<br>SIMD</td><td>控制器：一个<br>处理器：多个<br>主存模块：多个</td><td>各处理器以异步形式执行同一条指令</td><td>并行处理机<br>阵列处理机<br>超级向量处理机</td></tr><tr><td>多指令流单数据流<br>MISD</td><td>控制器：多个<br>处理器：一个<br>主存模块：多个</td><td>被证明不可能，至少是不实际</td><td>目前没有，有文献称流水线计算机为此类</td></tr><tr><td>多指令流多数据流<br>MIMD</td><td>控制器：多个<br>处理器：多个<br>主存模块：多个</td><td>能够实现作业、任务、指令等各级全面并行</td><td>多处理机系统<br>多计算机</td></tr></tbody></table><h1 id="二、CISC与RISC"><a href="#二、CISC与RISC" class="headerlink" title="二、CISC与RISC"></a>二、CISC与RISC</h1><table><thead><tr><th>指令系统类型</th><th>指令</th><th>寻址方式</th><th>实现方式</th><th>其他</th></tr></thead><tbody><tr><td>CISC(复杂)</td><td>数量多，使用频率差别大，可变长格式</td><td>支持多种</td><td>微程序控制技术</td><td>研制周期长</td></tr><tr><td>RISC(精简)</td><td>数量少，使用频率接近，定长格式，大部分为单调周期指令，操作寄存器，只有Load/Store操作内存</td><td>支持方式少</td><td>增加了通用寄存器；<br>硬布线逻辑控制为主；<br>适合采用流水线</td><td>优化编译，有效支持高级语言</td></tr></tbody></table><h1 id="三、层次化存储结构"><a href="#三、层次化存储结构" class="headerlink" title="三、层次化存储结构"></a>三、层次化存储结构</h1><p>CPU   $\rightarrow$ 寄存器<br>$\Updownarrow$<br>Cache  $\rightarrow$ 按内容存取<br>$\Updownarrow$<br>内存（主存）<br>$\Updownarrow$<br>外存（辅存）   $\rightarrow$ 硬盘、光盘、u盘等</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从上到下，容量逐渐增大</span><br><span class="line">速度逐渐变慢</span><br><span class="line">单位价格逐渐降低</span><br></pre></td></tr></tbody></table></figure><h1 id="四、Cache"><a href="#四、Cache" class="headerlink" title="四、Cache"></a>四、Cache</h1><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Cache的功能：提高CPU数据输入输出的速率，突破冯·诺伊曼瓶颈，即CPU与存储系统间数据传送带宽限制</span><br><span class="line">2. 在计算机的存储系统种，Cache是访问速度最快的层次</span><br><span class="line">3. 使用Cache改善系统性能的依据是程序的局部性原理</span><br></pre></td></tr></tbody></table></figure><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果以h代表Cache的访问命中率，t1表示Cache的周期时间，t2表示主存储器周期时间，以读操作为例，使用“Cache+主存储器”的系统的平均周期为t3，则</span><br><span class="line">                t3 = h * t1 + ( 1 - h ) * t2</span><br><span class="line">其中，( 1 - h )又称为失效率（未命中率）</span><br></pre></td></tr></tbody></table></figure><h1 id="五、局部性原理"><a href="#五、局部性原理" class="headerlink" title="五、局部性原理"></a>五、局部性原理</h1><h2 id="1-时间局部性"><a href="#1-时间局部性" class="headerlink" title="1. 时间局部性"></a>1. 时间局部性</h2><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果程序中的某条指令一旦执行，不久以后该指令可能再次执行;如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</span><br><span class="line">----被引用过一次的存储器位置在未来会被多次引用（通常在循环中）</span><br></pre></td></tr></tbody></table></figure><h2 id="2-空间局部性"><a href="#2-空间局部性" class="headerlink" title="2. 空间局部性"></a>2. 空间局部性</h2><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</span><br><span class="line">----如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</span><br></pre></td></tr></tbody></table></figure><h2 id="3-工作集理论"><a href="#3-工作集理论" class="headerlink" title="3. 工作集理论"></a>3. 工作集理论</h2><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把要被频繁访问的页面集合打包起来，并放到Cache使之短时间不被替换，达到高效的目的。</span><br></pre></td></tr></tbody></table></figure><h1 id="六、主存"><a href="#六、主存" class="headerlink" title="六、主存"></a>六、主存</h1><h2 id="1-分类"><a href="#1-分类" class="headerlink" title="1.分类"></a>1.分类</h2><ol><li>随机存取存储器<ul><li>DRAM(Dynamic RAM,动态RAM) - SDRAM</li><li>SRAM(Static RAM,静态)</li></ul></li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例子：内存</span><br><span class="line">特点：断电后内存中所有的数据都将被清除掉，无法保存</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>只读存储器<ul><li>MROM(Mask ROM,掩模式ROM)</li><li>PROM(Programmable ROM,一次可编程 ROM)</li><li>EPROM(Erasable PROM,可擦除的 PROM)</li><li>闪速存储器(flash memory,闪存)</li></ul></li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特点:断电后仍能存储相应的信息</span><br></pre></td></tr></tbody></table></figure><h2 id="2-编址"><a href="#2-编址" class="headerlink" title="2.编址"></a>2.编址</h2><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所谓主存的编址就是把芯片组成相应的存储器，在组成时往往需要分析什么样规格的芯片、多少块芯片能够组成按什么方式编址的存储空间。</span><br><span class="line"></span><br><span class="line">  比如 8*4位的存储器，8代表它有8个地址空间，4代表每个地址空间存储有4个比特位的信息。</span><br></pre></td></tr></tbody></table></figure><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">软考题型：</span><br><span class="line"></span><br><span class="line">     内存地址从AC000H到C7FFH,共有_ (1)_ K个地址单元， 如果该内存地址按字(16bit)</span><br><span class="line">编址，由28片存储器芯片构成。已知构成此内存的芯片每片有16K个存储单元，则该芯片每</span><br><span class="line">个存储单元存储_ _(2)_ 位。</span><br><span class="line"></span><br><span class="line">    （1）A. 96     B. 112      C. 132     D. 156</span><br><span class="line"></span><br><span class="line">    （2）A. 4       B. 8          C.16        D. 24</span><br><span class="line"></span><br><span class="line">解答：多少个地址单元：C7FFFH - AC000H + 1  ，C7FFFH + 1 = C8000H , C8000H -  AC000H = 1C000H  , 然后转化单位，（1H = 1024 K = 2^10 K）1C000 ÷ 2^10 = 112 ,故（1）选B。总容量为112K*16bit，设该芯片每个存储单元存储x 位,（112 * 16）/ （28 * 16 * x）= 1 , x = 4 ,故（2）选A</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成与体系结构 </tag>
            
            <tag> 软考 </tag>
            
            <tag> 高级架构师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE入门</title>
      <link href="/2022/04/29/vue-ru-men/"/>
      <url>/2022/04/29/vue-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h1><h2 id="vue-create命令"><a href="#vue-create命令" class="headerlink" title="vue create命令"></a>vue create命令</h2><figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create [option] &lt;app-name&gt;</span><br></pre></td></tr></tbody></table></figure><p>创建一个由vue-cle-service提供支持的新项目<br>option选项可以是</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-p, --preset &lt;presetName&gt;： 忽略提示符并使用已保存的或远程的预设选项</span><br><span class="line">-d, --default： 忽略提示符并使用默认预设选项</span><br><span class="line">-i, --inlinePreset &lt;json&gt;： 忽略提示符并使用内联的 JSON 字符串预设选项</span><br><span class="line">-m, --packageManager &lt;command&gt;： 在安装依赖时使用指定的 npm 客户端</span><br><span class="line">-r, --registry &lt;url&gt;： 在安装依赖时使用指定的 npm registry</span><br><span class="line">-g, --git [message]： 强制 / 跳过 git 初始化，并可选的指定初始化提交信息</span><br><span class="line">-n, --no-git： 跳过 git 初始化</span><br><span class="line">-f, --force： 覆写目标目录可能存在的配置</span><br><span class="line">-c, --clone： 使用 git clone 获取远程预设选项</span><br><span class="line">-x, --proxy： 使用指定的代理创建项目</span><br><span class="line">-b, --bare： 创建项目时省略默认组件中的新手指导信息</span><br><span class="line">-h, --help： 输出使用帮助信息</span><br></pre></td></tr></tbody></table></figure><p>例：</p><figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create project-name</span><br></pre></td></tr></tbody></table></figure><p>安装之后启动应用</p><figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></tbody></table></figure><h1 id="2-Vue3目录结构"><a href="#2-Vue3目录结构" class="headerlink" title="2.Vue3目录结构"></a>2.Vue3目录结构</h1><p>目录解析</p><table><thead><tr><th>目录/文件</th><th>说明</th></tr></thead><tbody><tr><td>build</td><td>项目构建(webpack)相关代码</td></tr><tr><td>config</td><td>配置目录，包括端口号等。我们初学可以使用默认的。</td></tr><tr><td>node_modules</td><td>npm 加载的项目依赖模块</td></tr><tr><td>src</td><td>这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件</td></tr><tr><td></td><td>assets: 放置一些图片，如logo等。</td></tr><tr><td></td><td>components: 目录里面放了一个组件文件，可以不用。</td></tr><tr><td></td><td>App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。</td></tr><tr><td></td><td>main.js: 项目的核心文件。</td></tr><tr><td></td><td>index.css: 样式文件。</td></tr><tr><td>static</td><td>静态资源目录，如图片、字体等。</td></tr><tr><td>public</td><td>公共资源目录。</td></tr><tr><td>test</td><td>初始测试目录，可删除</td></tr><tr><td>.xxxx文件</td><td>这些是一些配置文件，包括语法配置，git配置等。</td></tr><tr><td>index.html</td><td>首页入口文件，你可以添加一些 meta 信息或统计代码啥的。</td></tr><tr><td>package.json</td><td>项目配置文件。</td></tr><tr><td>README.md</td><td>项目的说明文档，markdown 格式</td></tr><tr><td>dist</td><td>使用 npm run build 命令打包后会生成该目录。</td></tr></tbody></table><h1 id="3-Vue3起步"><a href="#3-Vue3起步" class="headerlink" title="3. Vue3起步"></a>3. Vue3起步</h1><p>直接在页面引入 vue.global.js<br>Vue3中的应用是通过createApp函数来创建的，语法格式如下</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const app = Vue.createApp({/*选项*/})</span><br></pre></td></tr></tbody></table></figure><p>传递给createApp的选项用于配置根组件。在使用**mount()**挂载应用时，该组件被用作渲染的起点</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.createApp(HelloVueApp).mount('#hello-vue')</span><br></pre></td></tr></tbody></table></figure><p>createApp 的参数是根组件（HelloVueApp），在挂载应用时，该组件是渲染的起点。</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个应用需要被挂载到一个 DOM 元素中，以上代码使用**mount('#hello-vue')**将 Vue 应用 HelloVueApp 挂载到 &lt;div id="hello-vue"&gt;&lt;/div&gt; 中。</span><br><span class="line"> </span><br><span class="line">mount('#hello-vue') 将 Vue 应用 HelloVueApp 挂载到 &lt;div id="hello-vue"&gt;&lt;/div&gt; 中。</span><br><span class="line">{{ }} 用于输出对象属性和函数返回值。</span><br><span class="line">{{ message }} 对应应用中 message 的值。</span><br></pre></td></tr></tbody></table></figure><h3 id="data选项"><a href="#data选项" class="headerlink" title="data选项"></a>data选项</h3><p>data 选项是一个函数。Vue 在创建新组件实例的过程中调用此函数。它应该返回一个对象，然后 Vue 会通过响应性系统将其包裹起来，并以 $data 的形式存储在组件实例中。</p>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVN入门&#39;</title>
      <link href="/2022/04/29/svn-ru-men/"/>
      <url>/2022/04/29/svn-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="1-SVN入门简介"><a href="#1-SVN入门简介" class="headerlink" title="1.SVN入门简介"></a>1.SVN入门简介</h1><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subversion(SVN) 是一个开源的版本控制系統, 也就是说 Subversion 管理着随时间改变的数据。 这些数据放置在一个中央资料档案库(repository) 中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。</span><br></pre></td></tr></tbody></table></figure><h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h2><ol><li>repository（源代码库）:源代码统一存放的地方</li><li>Checkout（提取）:当你手上没有源代码的时候，你需要从repository checkout一份</li><li>Commit（提交）:当你已经修改了代码，你就需要Commit到repository</li><li>Update (更新):当你已经Checkout了一份源代码， Update一下你就可以和Repository上的源代码同步，你手上的代码就会有最新的变更<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">日常开发过程其实就是这样的（假设你已经Checkout并且已经工作了几天）：Update(获得最新的代码) --&gt;作出自己的修改并调试成功 --&gt; Commit(大家就可以看到你的修改了) 。</span><br><span class="line"></span><br><span class="line">如果两个程序员同时修改了同一个文件呢, SVN 可以合并这两个程序员的改动，实际上SVN管理源代码是以行为单位的，就是说两个程序员只要不是修改了同一行程序，SVN都会自动合并两种修改。如果是同一行，SVN 会提示文件 Conflict, 冲突，需要手动确认。</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="2-主要功能"><a href="#2-主要功能" class="headerlink" title="2. 主要功能"></a>2. 主要功能</h2><ol><li>目录版本控制<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVS 只能跟踪单个文件的历史, 不过 Subversion 实作了一个 "虚拟" 的版本控管文件系统, 能够依时间跟踪整个目录的变动。 目录和文件都能进行版本控制。</span><br></pre></td></tr></tbody></table></figure></li><li>真实的版本历史<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自从CVS限制了文件的版本记录，CVS并不支持那些可能发生在文件上，但会影响所在目录内容的操作，如同复制和重命名。除此之外，在CVS里你不能用拥有同样名字但是没有继承老版本历史或者根本没有关系的文件替换一个已经纳入系统的文件。在Subversion中，你可以增加（add）、删除（delete）、复制（copy）和重命名（rename），无论是文件还是目录。所有的新加的文件都从一个新的、干净的版本开始。</span><br></pre></td></tr></tbody></table></figure></li><li>自动提交<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个提交动作，不是全部更新到了档案库中，就是不完全更新。这允许开发人员以逻辑区间建立并提交变动，以防止当部分提交成功时出现的问题。</span><br></pre></td></tr></tbody></table></figure></li><li>纳入版本控管的元数据<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每一个文件与目录都附有一組属性关键字并和属性值相关联。你可以创建, 并儲存任何你想要的Key/Value对。 属性是随着时间来作版本控管的,就像文件內容一样。</span><br></pre></td></tr></tbody></table></figure></li><li>选择不同的网络层<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subversion 有抽象的档案库存取概念, 可以让人很容易地实作新的网络机制。 Subversion 可以作为一个扩展模块嵌入到Apache HTTP 服务器中。这个为Subversion提供了非常先进的稳定性和协同工作能力，除此之外还提供了许多重要功能: 举例来说, 有身份认证, 授权, 在线压缩, 以及文件库浏览等等。还有一个轻量级的独立Subversion服务器， 使用的是自定义的通信协议, 可以很容易地通过 ssh 以 tunnel 方式使用。</span><br></pre></td></tr></tbody></table></figure></li><li>一致的数据处理方式<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subversion 使用二进制差异算法来异表示文件的差异, 它对文字(人类可理解的)与二进制文件(人类无法理解的) 两类的文件都一视同仁。 这两类的文件都同样地以压缩形式储存在档案库中, 而且文件差异是以两个方向在网络上传输的。</span><br></pre></td></tr></tbody></table></figure></li><li>有效的分支(branch)与标签(tag)<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在分支与标签上的消耗并不必一定要与项目大小成正比。 Subversion 建立分支与标签的方法, 就只是复制该项目, 使用的方法就类似于硬连接（hard-link）。 所以这些操作只会花费很小, 而且是固定的时间。</span><br></pre></td></tr></tbody></table></figure></li><li>Hackability<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subversion没有任何的历史包袱; 它主要是一群共用的 C 程序库, 具有定义完善的API。这使得 Subversion 便于维护, 并且可被其它应用程序与程序语言使用。</span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> svn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架概述&#39;</title>
      <link href="/2022/04/11/spring-kuang-jia-gai-shu/"/>
      <url>/2022/04/11/spring-kuang-jia-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring框架概述"><a href="#Spring框架概述" class="headerlink" title="Spring框架概述"></a>Spring框架概述</h2><ol><li>Spring是轻量级的开源的J2EE框架</li><li>Spring可以解决企业开发的复杂性</li><li>Spring有两个核心部分：IOC和AOP<ol><li>IOC:控制反转，把创建对象过程交给Spring进行管理</li><li>AOP：面向切面，不修改源代码进行功能增强</li></ol></li><li>Spring特点<ol><li>方便解耦，简化开发</li><li>AOP编程支持</li><li>方便程序的测试</li><li>方便集成各种优秀框架</li><li>方便进行事务操作</li><li>降低API使用难度</li><li>Java源码是经典学习范例</li></ol></li></ol><h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><ol><li>IOC概念<ol><li>什么是IOC <figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理</span><br></pre></td></tr></tbody></table></figure></li><li>使用IOC的目的<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">降低耦合度</span><br></pre></td></tr></tbody></table></figure></li></ol></li><li>IOC底层原理<ol><li>xml解析、工厂模式、反射 <figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 配置对象的xml文件</span><br><span class="line">2. 创建工厂类</span><br><span class="line">3. 解析xml获取class路径</span><br><span class="line">4. 通过反射创建对象</span><br><span class="line">5. 返回该对象</span><br></pre></td></tr></tbody></table></figure></li></ol></li><li>IOC接口(BeanFactory)<ol><li>IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</li><li>Spring提供IOC容器实现两种方式：(两个接口)<ol><li>BeanFactory<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用</span><br><span class="line">*加载配置文件时不会创建对象，在获取(使用)对象时才会创建对象</span><br></pre></td></tr></tbody></table></figure></li><li>ApplicationContext<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用</span><br><span class="line">*在加载配置文件时就会把配置文件的对象进行创建</span><br></pre></td></tr></tbody></table></figure></li><li>ApplicationContext接口又实现类</li></ol></li></ol></li><li>IOC操作Bean管理<ol><li>什么是Bean管理<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bean管理指的是两个操作</span><br><span class="line">1.Spring创建对象</span><br><span class="line">2.Spring注入属性</span><br></pre></td></tr></tbody></table></figure></li><li>Bean管理操作有两种方式<ol><li>基于xml配置文件方式实现<figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 在Spring配置文件中，使用bean标签，标签里添加对应属性，就可以实现对象创建</span><br><span class="line">2. 在bean标签有很多属性</span><br><span class="line">   1. id：唯一标识</span><br><span class="line">   2. calss：创建对象的全路径</span><br><span class="line">   3. name：与id类似，可以有特殊字符</span><br><span class="line"></span><br><span class="line">3. 创建对象时，默认是执行无参构造方法完成对象创建</span><br></pre></td></tr></tbody></table></figure></li><li>基于xml方式注入属性<ol><li><p>DI：依赖注入，就是注入属性</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 使用set方法进行注入</span><br><span class="line">   1. 创建类，定义属性和对应的set方法</span><br><span class="line">   2. 在Spring配置文件中配置对象创建，配置属性注入</span><br><span class="line">2. 使用有参构造注入</span><br><span class="line">   1. 创建类，定义属性，定义有参构造方法</span><br></pre></td></tr></tbody></table></figure></li><li><p>p名称空间注入（了解）</p><ol><li>添加p名称空间在配置文件中</li><li>进行属性注入，在bean标签里面使用p:属性名进行操作</li></ol></li><li><p>xml注入其他类型属性</p><ol><li>字面量<ol><li>null值：使用null标签</li><li>属性值包含特殊符号<ol><li>使用转义字符</li><li>把特殊符号内容写到CDATA中</li></ol></li></ol></li></ol></li><li><p>注入属性-外部bean</p><ol><li>创建两个类：例如service类和DAO类</li><li>在service中调用dao里面的方法</li><li>在Spring配置文件中进行配置</li></ol></li><li><p>注入属性-内部bean和级联赋值</p><ol><li>一对多关系</li><li>在实体之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示</li></ol></li><li><p>注入集合类型属性</p><ol><li>创建类，定义数组、list、map、set类型属性，生成对应set方法</li><li>在spring配置文件中进行配置</li></ol></li></ol></li><li>基于注解方式实现</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 计算机系统概述</title>
      <link href="/2022/03/18/di-yi-zhang-ji-suan-ji-xi-tong-gai-shu/"/>
      <url>/2022/03/18/di-yi-zhang-ji-suan-ji-xi-tong-gai-shu/</url>
      
        <content type="html"><![CDATA[<p>1.1列出并简要定义计算机的4个主要组成部分。</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 处理器（processor）：控制计算机的操作，执行数据处理功能。当只有一个处理器时，</span><br><span class="line">它通常指中央处理单元（CPU）。</span><br><span class="line">2. 内存（main memory）：存储数据和程序。此类存储器通常是易失性的，即当计算机关机</span><br><span class="line">时，存储器的内容会丢失。相反，当计算机关机时，磁盘存储器的内容不会丢失。内存</span><br><span class="line">通常也称为实存储器（real memory）或主存储器（primary memory）。</span><br><span class="line">3. 输入/输出模块（I/O module）：在计算机和外部环境之间移动数据。外部环境由各种外</span><br><span class="line">部设备组成，包括辅助存储器设备（如硬盘）、通信设备和终端。</span><br><span class="line">4. 系统总线（system bus）：为处理器、内存和输入/输出模块间提供通信的设施。</span><br></pre></td></tr></tbody></table></figure><p>1.2定义处理器寄存器的两种主要类别。</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 用户可见寄存器:优先使用这些寄存器,可以使机器语言或者汇编语言的程序员减少对主存储器的访问次数。对高级语言而言，由优化编译器负责决定把哪些变量应该分配给主存储器。一些些高级语言,如C语言,允许程序言建议编译器把哪些变量保存在寄存器中。</span><br><span class="line">2. 控制和状态寄存器:用以控制处理器的操作,且主要被具有特权的操作系统例程使用,以控制程序的执行。</span><br></pre></td></tr></tbody></table></figure><p>1.3一般而言，一条机器指令能指定的4种不同操作是什么</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 处理器-寄存器:数据</span><br><span class="line">以从处理器传送到存储器,或者从存储器传送到处理器。</span><br><span class="line">2. 处理器-I/O:通过处理器和I/O模块间的数据传送,数据可以输出到外部设备,或者从外部设备输入数据。</span><br><span class="line">3. 数据处理:处理器可以执行很多关于数据的算术操作或逻辑操作。</span><br><span class="line">4. 控制:某些指令可以改变执行顺序。</span><br></pre></td></tr></tbody></table></figure><p>1.4什么是中断?</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其他模块（I/O,存储器）终端处理器正常处理过程的机制</span><br></pre></td></tr></tbody></table></figure><p>1.5多个中断的处理方式是什么?</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一种：当正在处理一个中断时，禁止再次发生中断</span><br><span class="line"></span><br><span class="line">第二种：定义中断优先级，允许高优先级中断打断低优先级的中断处理器的运行</span><br></pre></td></tr></tbody></table></figure><p>1.6内存层次各个元素间的特征是什么?</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">价格</span><br><span class="line">容量</span><br><span class="line">访问时间</span><br><span class="line"></span><br><span class="line">自上而下看时：</span><br><span class="line">a.每“位”的价格递减</span><br><span class="line">b.容量递增</span><br><span class="line">c.存取时间递增</span><br><span class="line">d.处理器访问存储器的频率递减</span><br></pre></td></tr></tbody></table></figure><p>1.7什么是高速缓存?</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">高速缓冲时比主存小而快的存储器，用以协调主存跟处理器，作为最近的储存地址的缓冲区</span><br></pre></td></tr></tbody></table></figure><p>1.8多处理器系统和多核系统的区别是什么?</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、概念上的区别：</span><br><span class="line"></span><br><span class="line">多处理器系统中包含多个单核处理器，就是说电脑和处理器有多个，但电脑的处理器是单核的；多核处理器系统指系统中只有一个多核心的处理器，也就是说电脑只有一个处理器，但是这个处理器是多核的。</span><br><span class="line"></span><br><span class="line">2、资源利用率的区别：</span><br><span class="line"></span><br><span class="line">对于多处理器系统而言，它们在执行命令的时候多个处理器之间的通信手段是电脑主板上的总线。而对于多核系统而言，多个核心处理器之间通信时通过CPU内部总线进行信息的交互的。对于执行效率而言，多核处理器要优于多个处理器。</span><br><span class="line"></span><br><span class="line">3、线程控制上的区别：</span><br><span class="line"></span><br><span class="line">计算机在启动之后，一个进程最少包含一个主线程，如果这个主线程结束了，那么这个进程也就终止执行了，主线程是以函数的形式提供给操作系统的。对于并行计算是在多处理器的情况下，操作系统把多个线程分配给响应的处理器，然后各自执行任务。</span><br></pre></td></tr></tbody></table></figure><p>1.9空间局部性和时间局部性之间的区别是什么?</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">时间局部性:</span><br><span class="line">如果在某一点时访问了存储器的特定位置，则很可能在不久的将来将再次访问相同的位置。在对相同存储器位置的相邻访问之间存在时间接近性。</span><br><span class="line">在这种情况下，通常努力将访问过的数据的副本存储在可以被更快访问的特殊存储器中。时间局部性是空间局部性的特殊情况，即当预期位置与当前位置相同时。</span><br><span class="line"></span><br><span class="line">空间局部性:</span><br><span class="line">如果特定存储位置在特定时间被访问，则很可能在不久的将来访问附近的存储位置。在这种情况下，通常尝试猜测当前访问周围的区域的大小和形状，对于该区域，值得准备更快的访问。</span><br></pre></td></tr></tbody></table></figure><p>1.10开发空间局部性和时间局部性的策略是什么?</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程运行时，在一段时间里，程序的执行往往呈现高度的局部性，包括时间局部性和空间局部性。时间局部性是一旦一个指令被执行了，则在不久的将来，它可能再被执行。空间局部性是一旦一个指令一个存储单元被访问，那么它附近的单元也将很快被访问。程序的局部性原理是虚拟存储技术引入的前提。虚拟存储的实现原理是，当进程要求运行时，不是将它全部装入内存，而是将其一部分装入内存，另一部分暂时不装入内存。</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 习题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell编程概述</title>
      <link href="/2022/02/01/shell-bian-cheng/"/>
      <url>/2022/02/01/shell-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Shell编程概述"><a href="#1-Shell编程概述" class="headerlink" title="1. Shell编程概述"></a>1. Shell编程概述</h1><h2 id="1-1-Shell名词解释"><a href="#1-1-Shell名词解释" class="headerlink" title="1.1 Shell名词解释"></a>1.1 Shell名词解释</h2><ul><li><p>Kernel</p><ul><li>Linux内核主要是为了和硬件打交道</li></ul></li><li><p>Shell</p><ul><li>命令解释器（command interpreter）</li><li>Shell 是一个用C语言编写的程序，它时用户使用Linux的桥梁。Shell既是一种命令语言，又是一种程序设计语言</li><li>Shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务</li></ul></li><li><p>Shell两大主流</p><ul><li>sh:<ul><li>Bourne shell (sh) , Solaris,hpux默认Shell</li><li>Bourne again sell(bash),Linux默认shell</li></ul></li><li>csh<ul><li>C shell (csh)</li><li>tc shell (tcsh)</li></ul></li></ul></li><li><p><strong>#!</strong> 声明</p><ul><li>告诉系统其后路径所指定的程序即是解释此脚本文件的Shell程序</li><li>```sh<br>  #!/bin/bash<br>  echo “Hello World !”<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">##  1.2 Shell脚本的执行</span><br><span class="line">- 输入脚本的绝对路径或相对路径</span><br><span class="line">    - /root/helloworld.sh</span><br><span class="line">    - ./helloworld.sh</span><br><span class="line">    - 执行的必须是一个可执行文件</span><br><span class="line">- bash或sh+脚本</span><br><span class="line">- sh hellowrld.sh</span><br><span class="line">- 当脚本没有x权限时，root和文件所有者通过该方式可以正常执行</span><br><span class="line">- 在脚本的路径前再加"."或source</span><br><span class="line">    - source helloworld.sh</span><br><span class="line">- 区别</span><br><span class="line">    - 绝对路径、相对路径或者bash、sh会新开一个bash，不同bash中的变量无法共享</span><br><span class="line">    - 第三种是在同一个shell里执行的</span><br><span class="line">- export：可以将当前进程的变量传递给子进程去使用</span><br><span class="line">    - 将来配置profile的时候，所有的变量前必须加export</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  Shell 基础入门</span><br><span class="line">##  2.1 Shell 变量</span><br><span class="line">- 定义变量时，变量名不加美元符号</span><br><span class="line">    - 命名只能使用英文字母，数字和下划线，首个字母不能以数字开头。</span><br><span class="line">    - 中间不能有空格，可以使用下划线</span><br><span class="line">    - 不能使用标点符号。</span><br><span class="line">    - 不能使用bash里的关键字(可用help命令查看保留关键字)</span><br><span class="line">- 变量的类型</span><br><span class="line">    - 局部变量</span><br><span class="line">        - 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量</span><br><span class="line">    - 环境变量</span><br><span class="line">        - 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行</span><br><span class="line">    - Shell变量</span><br><span class="line">        - shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分时局部变量</span><br><span class="line">-</span><br><span class="line">```sh</span><br><span class="line"># 变量的声明</span><br><span class="line">name="zhangsan"</span><br><span class="line">for file in `ls /etc`</span><br><span class="line">或</span><br><span class="line">for file in $(ls /etc)</span><br><span class="line"></span><br><span class="line"># 变量的调用</span><br><span class="line">echo $name</span><br><span class="line">echo ${name}</span><br><span class="line"></span><br><span class="line">for skill in Ada Coffe Action Java; do</span><br><span class="line">    echo "I am good at ${skill}Script"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 只读变量 /bin/sh: NAME: This variable is read only</span><br><span class="line">url="https://www.google.com"</span><br><span class="line">readonly url</span><br><span class="line">url="https://www.runoob.com"</span><br><span class="line"></span><br><span class="line"># 删除变量</span><br><span class="line">unset name</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript类</title>
      <link href="/2022/01/01/typescript-lei/"/>
      <url>/2022/01/01/typescript-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="TypeScript类"><a href="#TypeScript类" class="headerlink" title="TypeScript类"></a>TypeScript类</h2><p>TypeScript 是面向对象的 JavaScript。<br>类描述了所创建的对象共同的属性和方法。<br>TypeScript 支持面向对象的所有特性，比如 类、接口等。<br>TypeScript 类定义方式如下：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">class_name</span> {</span><br><span class="line"><span class="comment">//类作用域</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>定义类的关键字为 class，后面紧跟类名，类可以包含以下几个模块（类的数据成员）：</p><ol><li>字段 − 字段是类里面声明的变量。字段表示对象的有关数据。</li><li>构造函数 − 类实例化时调用，可以为类的对象分配内存。</li><li>方法 − 方法为对象要执行的操作。</li></ol><h3 id="创建实例化对象"><a href="#创建实例化对象" class="headerlink" title="创建实例化对象"></a>创建实例化对象</h3><p>使用new关键字来实例化类的对象</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object_name = <span class="keyword">new</span> <span class="title function_">class_name</span>([<span class="variable language_">arguments</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//类实例化时会调用构造函数</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">""</span>engine <span class="number">1</span><span class="string">""</span>)</span><br><span class="line"> <span class="comment">//访问属性</span></span><br><span class="line"> obj.<span class="property">field_name</span></span><br><span class="line"> obj.<span class="title function_">function_name</span>()</span><br></pre></td></tr></tbody></table></figure><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>Typescript支持继承类，即我们可以在创建类的时候继承一个已存在的类，这个已存在的类称为父类，继承它的类为子类<br>类继承使用关键字extends，子类除了不能继承父类的私有成员（方法和属性）和构造函数，其他的都可以继承<br>TypeScript一次只能继承一个类，不支持继承多个类，但是支持多重继承（A继承B，B继承C）</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">child_class_name</span> <span class="keyword">extends</span> <span class="title class_ inherited__">parent_class_name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> { </span><br><span class="line">   <span class="title class_">Area</span>:<span class="built_in">number</span> </span><br><span class="line">   </span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">a:<span class="built_in">number</span></span>) { </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">Area</span> = a </span><br><span class="line">   } </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> { </span><br><span class="line">   <span class="title function_">disp</span>():<span class="built_in">void</span> { </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span>圆的面积:  <span class="string">""</span>+<span class="variable language_">this</span>.<span class="property">Area</span>) </span><br><span class="line">   } </span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">223</span>); </span><br><span class="line">obj.<span class="title function_">disp</span>()</span><br></pre></td></tr></tbody></table></figure><h3 id="继承类的方法重写"><a href="#继承类的方法重写" class="headerlink" title="继承类的方法重写"></a>继承类的方法重写</h3><p>类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写<br>其中super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrinterClass</span> { </span><br><span class="line">   <span class="title function_">doPrint</span>():<span class="built_in">void</span> {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span>父类的 <span class="title function_">doPrint</span>() 方法。<span class="string">""</span>) </span><br><span class="line">   } </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringPrinter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">PrinterClass</span> { </span><br><span class="line">   <span class="title function_">doPrint</span>():<span class="built_in">void</span> { </span><br><span class="line">      <span class="variable language_">super</span>.<span class="title function_">doPrint</span>() <span class="comment">// 调用父类的函数</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span>子类的 <span class="title function_">doPrint</span>()方法。<span class="string">""</span>)</span><br><span class="line">   } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p>static关键字用于定义类的数据成员（属性和方法）为静态的，静态成员可以直接通过类名调用</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticMem</span> {  </span><br><span class="line">   <span class="keyword">static</span> <span class="attr">num</span>:<span class="built_in">number</span>; </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span> <span class="title function_">disp</span>():<span class="built_in">void</span> { </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span>num 值为 <span class="string">""</span>+ <span class="title class_">StaticMem</span>.<span class="property">num</span>) </span><br><span class="line">   } </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="title class_">StaticMem</span>.<span class="property">num</span> = <span class="number">12</span>     <span class="comment">// 初始化静态变量</span></span><br><span class="line"><span class="title class_">StaticMem</span>.<span class="title function_">disp</span>()       <span class="comment">// 调用静态方法</span></span><br></pre></td></tr></tbody></table></figure><h3 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h3><p>instanceof 运算符用于判断对象是否是指定的类型，如果是返回 true，否则返回 false。</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>{ } </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Person</span>() </span><br><span class="line"><span class="keyword">var</span> isPerson = obj <span class="keyword">instanceof</span> <span class="title class_">Person</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span>obj 对象是 <span class="title class_">Person</span> 类实例化来的吗？ <span class="string">""</span> + isPerson);</span><br></pre></td></tr></tbody></table></figure><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>TypeScript 中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。TypeScript 支持 3 种不同的访问权限。</p><ul><li>public（默认） : 公有，可以在任何地方被访问。</li><li>protected : 受保护，可以被其自身以及其子类和父类访问。</li><li>private : 私有，只能被其定义所在的类访问。</li></ul><p>以下实例定义了两个变量 str1 和 str2，str1 为 public，str2 为 private，实例化后可以访问 str1，如果要访问 str2 则会编译错误</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Encapsulate</span> { </span><br><span class="line">   <span class="attr">str1</span>:<span class="built_in">string</span> = <span class="string">""</span>hello<span class="string">""</span> </span><br><span class="line">   <span class="keyword">private</span> <span class="attr">str2</span>:<span class="built_in">string</span> = <span class="string">""</span>world<span class="string">""</span> </span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Encapsulate</span>() </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">str1</span>)     <span class="comment">// 可访问 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">str2</span>)   <span class="comment">// 编译错误， str2 是私有的</span></span><br></pre></td></tr></tbody></table></figure><h3 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h3><p>类可以实现接口，使用关键字implement，并将interface字段作为类的属性使用</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ILoan</span> { </span><br><span class="line">   <span class="attr">interest</span>:<span class="built_in">number</span> </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgriLoan</span> <span class="keyword">implements</span> <span class="title class_">ILoan</span> { </span><br><span class="line">   <span class="attr">interest</span>:<span class="built_in">number</span> </span><br><span class="line">   <span class="attr">rebate</span>:<span class="built_in">number</span> </span><br><span class="line">   </span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">interest:<span class="built_in">number</span>,rebate:<span class="built_in">number</span></span>) { </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">interest</span> = interest </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">rebate</span> = rebate </span><br><span class="line">   } </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">AgriLoan</span>(<span class="number">10</span>,<span class="number">1</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span>利润为 : <span class="string">""</span>+obj.<span class="property">interest</span>+<span class="string">""</span>，抽成为 : <span class="string">""</span>+obj.<span class="property">rebate</span> )</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE学前准备</title>
      <link href="/2022/01/01/vue-xue-qian-zhun-bei/"/>
      <url>/2022/01/01/vue-xue-qian-zhun-bei/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>VUE是一套用户构建用户界面的<em><strong>渐进式框架</strong></em>，发布与2014年2月，与其他大型框架不同的是，VUE被设计为可以自底向上逐层应用，VUE的核心库只关注视图层，不仅易于上手，还便于与地方哭或既有项目整合</p><p><a href="https://cn.vuejs.org/v2/guide/#">https://cn.vuejs.org/v2/guide/#</a> 前端知识体系</p><h2 id="前端三要素"><a href="#前端三要素" class="headerlink" title="前端三要素"></a>前端三要素</h2><ul><li>HTML（结构）：超文本标记语言，决定网页的结构和内容</li><li>CSS（表现）：层叠样式表，设定网页的表现样式</li><li>JavaScript（行为）：是一种弱类型脚本语言，其源代码不需要经过编译，而是由浏览器解释运行，用于控制网页的行为</li></ul><h2 id="结构层（HTML）"><a href="#结构层（HTML）" class="headerlink" title="结构层（HTML）"></a>结构层（HTML）</h2><h2 id="表现层（CSS）"><a href="#表现层（CSS）" class="headerlink" title="表现层（CSS）"></a>表现层（CSS）</h2><p>CSS层叠样式表示一门标记语言，并不是编程语言，因此不可以自定义变量，不也已引用等，不具备任何语法支持</p><p>缺点：</p><ul><li>语法不够强大，无法嵌套书写，导致模块化开发中需要书写很多重复的选择器</li><li>没有变量和合理的样式复用机制，是的逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护</li></ul><p>解决：</p><p>使用css预处理器的工具，提供CSS缺失的样式复用机制，减少荣誉代码，提高样式代码的可维护性，大大提高了前端样式上的开发效率</p><h3 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h3><p>CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加一些编程特性，将CSS作为目标生成文件，让后开发者就只要使用这种语言进行CSS的编码工作。</p><p>***本质就是用一种专门的编程语言，进行Web的页面样式设计，再通过编译器转换为正常的CSS文件，供项目使用</p><ul><li>SASS：基于Ruby没通过服务器端吃力，功能强大，解析效率高，需要学习Ruby语言，上手难度较大</li><li>LESS：基于NodeJS，通过客户端处理，使用简单，功能比SASS简单，解析效率也低于SASS，但实际开发中足够了，建议使用</li></ul><h2 id="行为层（JavaScript）"><a href="#行为层（JavaScript）" class="headerlink" title="行为层（JavaScript）"></a>行为层（JavaScript）</h2><p>JavaScript是一门弱类型脚本语言，其源代码在发往客户端运行之前不需要经过编译，而是将文本格式的字符代码发送给浏览器由浏览器解释运行</p><h3 id="Native原生JS开发"><a href="#Native原生JS开发" class="headerlink" title="Native原生JS开发"></a>Native原生JS开发</h3><p>原生JS开发，也就是让我们按照<em><strong>ECMAScript</strong></em>标准的开发方式，简称ES，特点是所有浏览器都支持</p><p>ES3~ES9</p><p>ES5全浏览器支持<br>ES6常用，当前主流版本，webpack打包成ES5支持<br>ES9（草案阶段）区别就是逐步增加新特性</p><p>TypeScript微软的标准</p><p>TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程，</p><p>改语言的特点就是除了具备ES的特性之外还奶入了许多不在标准范围内的新特性，所以会导致很多浏览器不能直接支持TypeScript语法，需要编译后（编译成JS）才能被浏览器正确执行</p><h2 id="JavaScript框架"><a href="#JavaScript框架" class="headerlink" title="JavaScript框架"></a>JavaScript框架</h2><ul><li>jQuery：简化了DOM操作，缺点是DOM操作太频繁，影响前端性能，但是兼容IE6、7、8</li><li>Angular：Google收购的前端框架，由一群Java程序员开发，特点是将后台的MVC模式搬到了前端并增加了<em><strong>模块化开发</strong></em>的理念，采用TypeScript语法开发，对前端不友好，对后端程序员友好，版本迭代不合理</li><li>React：Facebook出品，一款高性能JS前端框架，提出了新概念<strong>虚拟DOM</strong>用于减少真实DOM操作，在内存中模拟DOM操作，有效提升了前端渲染效率，缺点是使用复杂，需要额外学习<strong>JSX</strong>语言</li><li>Vue：渐进式JavaScript框架，渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性，综合了Angular（模块化）和React（虚拟DOM）的优点</li><li>Axios：前端通信框架；因为VUE就是为了处理Dom，所以并不具备通信能力，此时就需额外使用一个通信框架和服务器交互；当然也可以直接选择使用jQuery提供的AJAX通信功能</li></ul><h2 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h2><ul><li>Ant-Design:阿里巴巴出品，基于React的UI框架</li><li>ElementUi、iview、ice：饿了么出品，基于VUE的UI框架</li><li>Bootstrap：Twitter推测出的一个用于前端开发的开源工具包</li><li>AmazeUI：一款HTML5跨屏前端框架</li></ul><h2 id="JavaScript构建工具"><a href="#JavaScript构建工具" class="headerlink" title="JavaScript构建工具"></a>JavaScript构建工具</h2><ul><li>Babel：JS编译工具，主要用于浏览器不支持的ES新特性，比如用于编译TypeScript</li><li>WebPack：模块打包器，主要作用是打包、压缩、合并及按序加载</li></ul><h1 id="三端统一"><a href="#三端统一" class="headerlink" title="三端统一"></a>三端统一</h1><h2 id="混合开发（Hybrid-App）"><a href="#混合开发（Hybrid-App）" class="headerlink" title="混合开发（Hybrid App）"></a>混合开发（Hybrid App）</h2><p>主要目的是实现一套代码三端统一（PC、Android：.apk、IOS：.ipa）并能够调用到设备底层硬件，打包方式主要有两种：</p><ul><li>云打包：Hbuild-&gt;HBulidX，DCloud出品；API Cloud</li><li>本地打包：Cordova（前身是PhoneGap）</li></ul><h1 id="后端技术"><a href="#后端技术" class="headerlink" title="后端技术"></a>后端技术</h1><p>前端人员为了方便开发也需要掌握一定的后端技术，但Java后台人员指导后台知识体系机器庞大复杂，所以为了方便前端人员开发后台应用，就出现了NodeJS这样的技术</p><p>NodeJS框架以及项目管理工具如下：</p><ul><li>Express：NodeJS框架</li><li>Koa：Express简化版</li><li>NPM：项目综合管理工具，类似于Maven</li><li>YARN：NPM的替代方案，类似于Maven和Gradle的关系</li></ul><h2 id="主流前端框架"><a href="#主流前端框架" class="headerlink" title="主流前端框架"></a>主流前端框架</h2><p>Vue.js</p><h3 id="iView"><a href="#iView" class="headerlink" title="iView"></a>iView</h3><p>iview是一个强大的基于Vue的UI库，有很多实用的基础组件比elementui的组件更丰富，主要服务于PC界面的中后台产品。使用单文件的Vue组件化开发模式，基于npm+webpack+babel开发，支持ES2015高质量、功能丰富友好的API，自由灵活地使用空间<br><strong>属于前端主流框架，选型时可考虑使用，主要特点是移动端支持比较多</strong></p><h3 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h3><p>Element是饿了么前端开源维护的VueUI组件库，组件齐全，基本涵盖后台所需的所有组件，文档讲解详细，例子也很丰富。主要用于开发PC端的页面，是一个质量比较高的VueUI组件库</p><p><strong>属于前端主流框架，选型时可考虑使用，主要特点是桌面端支持比较多</strong></p><h3 id="ICE"><a href="#ICE" class="headerlink" title="ICE"></a>ICE</h3><p>飞冰是阿里巴巴团队基于React/Angular/Vue的中后台应用解决方案，在阿里巴巴内部，已经有270多个来自几乎所有BU的项目在使用，飞冰包含了一套从设计端到开发1端的完整链路，帮助用户快速搭建属于自己的中后台应用。</p><p><strong>主要组件还是以React为主</strong></p><h1 id="后端为主的MVC时代"><a href="#后端为主的MVC时代" class="headerlink" title="后端为主的MVC时代"></a>后端为主的MVC时代</h1><p>为了降低开发的复杂度，以后端为出发点</p><p>例：SpringMVC流程</p><ol><li>发起请求到前端控制器</li><li>前端控制器请求HandlerMapping查找Handler，可以根据xml配置、注解进行查找对应的处理器，并返回给前端控制器</li><li>前端控制器根据返回的数据查找对应的处理器并执行</li><li>处理器执行完给支配器返回ModelAndView</li><li>前端控制请请求视图解析器进行解析，根据逻辑视图名解析成真正的视图</li><li>视图解析器向前端控制器返回view</li><li>前端控制器进行视图渲染，视图渲染将模型数据（在ModelAndView对象中）填充到request域</li><li>前端控制器向用户响应结果</li></ol><h1 id="前端为主的MV-时代"><a href="#前端为主的MV-时代" class="headerlink" title="前端为主的MV*时代"></a>前端为主的MV*时代</h1><ul><li>MVC（同步通信为主）：Model、View、Controller</li><li>MVP（异步通信为主）：Model、View、Presenter</li><li>MVVM（异步通信为主：Model、View、ViewModel</li></ul><p>为了降低前端开发复杂度，涌现了大量的前端框架，比如：AngularJS、React、Vue.JS、EmberJS等，这些框架总的原则是先按类型分层，比如Templates、Controllers、Models，然后在在层内做分切</p>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript接口</title>
      <link href="/2022/01/01/typescript-jie-kou/"/>
      <url>/2022/01/01/typescript-jie-kou/</url>
      
        <content type="html"><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="keyword">interface</span> interface_name{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> { </span><br><span class="line">    <span class="attr">firstName</span>:<span class="built_in">string</span>, </span><br><span class="line">    <span class="attr">lastName</span>:<span class="built_in">string</span>, </span><br><span class="line">    <span class="attr">sayHi</span>: <span class="function">()=&gt;</span><span class="built_in">string</span> </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> <span class="attr">customer</span>:<span class="title class_">IPerson</span> = { </span><br><span class="line">    <span class="attr">firstName</span>:<span class="string">""</span><span class="title class_">Tom</span><span class="string">""</span>,</span><br><span class="line">    <span class="attr">lastName</span>:<span class="string">""</span><span class="title class_">Hanks</span><span class="string">""</span>, </span><br><span class="line">    <span class="attr">sayHi</span>: ():<span class="function"><span class="params">string</span> =&gt;</span>{<span class="keyword">return</span> <span class="string">""</span><span class="title class_">Hi</span> there<span class="string">""</span>} </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span><span class="title class_">Customer</span> 对象 <span class="string">""</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(customer.<span class="property">firstName</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(customer.<span class="property">lastName</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(customer.<span class="title function_">sayHi</span>())  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> <span class="attr">employee</span>:<span class="title class_">IPerson</span> = { </span><br><span class="line">    <span class="attr">firstName</span>:<span class="string">""</span><span class="title class_">Jim</span><span class="string">""</span>,</span><br><span class="line">    <span class="attr">lastName</span>:<span class="string">""</span><span class="title class_">Blakes</span><span class="string">""</span>, </span><br><span class="line">    <span class="attr">sayHi</span>: ():<span class="function"><span class="params">string</span> =&gt;</span>{<span class="keyword">return</span> <span class="string">""</span><span class="title class_">Hello</span>!!!<span class="string">""</span>} </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span><span class="title class_">Employee</span>  对象 <span class="string">""</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(employee.<span class="property">firstName</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(employee.<span class="property">lastName</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="联合类型接口"><a href="#联合类型接口" class="headerlink" title="联合类型接口"></a>联合类型接口</h2><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">RunOptions</span> { </span><br><span class="line">    <span class="attr">program</span>:<span class="built_in">string</span>; </span><br><span class="line">    <span class="attr">commandline</span>:<span class="built_in">string</span>[]|<span class="built_in">string</span>|(<span class="function">()=&gt;</span><span class="built_in">string</span>); </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="comment">// commandline 是字符串</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">options</span>:<span class="title class_">RunOptions</span> = {<span class="attr">program</span>:<span class="string">""</span>test1<span class="string">""</span>,<span class="attr">commandline</span>:<span class="string">""</span><span class="title class_">Hello</span><span class="string">""</span>}; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(options.<span class="property">commandline</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// commandline 是字符串数组</span></span><br><span class="line">options = {<span class="attr">program</span>:<span class="string">""</span>test1<span class="string">""</span>,<span class="attr">commandline</span>:[<span class="string">""</span><span class="title class_">Hello</span><span class="string">""</span>,<span class="string">""</span><span class="title class_">World</span><span class="string">""</span>]}; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(options.<span class="property">commandline</span>[<span class="number">0</span>]); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(options.<span class="property">commandline</span>[<span class="number">1</span>]);  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// commandline 是一个函数表达式</span></span><br><span class="line">options = {<span class="attr">program</span>:<span class="string">""</span>test1<span class="string">""</span>,<span class="attr">commandline</span>:<span class="function">()=&gt;</span>{<span class="keyword">return</span> <span class="string">""</span>**<span class="title class_">Hello</span> <span class="title class_">World</span>**<span class="string">""</span>;}}; </span><br><span class="line"><span class="comment">//方法需要额外定义接收</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">fn</span>:<span class="built_in">any</span> = options.<span class="property">commandline</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>());</span><br></pre></td></tr></tbody></table></figure><h2 id="接口和数组"><a href="#接口和数组" class="headerlink" title="接口和数组"></a>接口和数组</h2><p>接口中我们可以将数组的索引值和元素设置为不同的类型，索引值可以是数字或字符串</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> namelist { </span><br><span class="line">   [<span class="attr">index</span>:<span class="built_in">number</span>]:<span class="built_in">string</span> </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> <span class="attr">list2</span>:namelist = [<span class="string">""</span><span class="title class_">John</span><span class="string">""</span>,<span class="number">1</span>,<span class="string">""</span><span class="title class_">Bran</span><span class="string">""</span>] <span class="comment">// 错误元素 1 不是 string 类型</span></span><br><span class="line"><span class="keyword">interface</span> ages { </span><br><span class="line">   [<span class="attr">index</span>:<span class="built_in">string</span>]:<span class="built_in">number</span> </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> <span class="attr">agelist</span>:ages; </span><br><span class="line">agelist[<span class="string">""</span><span class="title class_">John</span><span class="string">""</span>] = <span class="number">15</span>   <span class="comment">// 正确 </span></span><br><span class="line">agelist[<span class="number">2</span>] = <span class="string">""</span>nine<span class="string">""</span>   <span class="comment">// 错误</span></span><br></pre></td></tr></tbody></table></figure><p><em><strong>个人理解</strong></em></p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有点像java中的linkedhashmap结构</span><br></pre></td></tr></tbody></table></figure><h2 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h2><p>接口继承就是说接口可以通过其他接口来扩展自己<br>TypeScript允许接口继承多个接口<br>继承关键字<strong>extends</strong>。</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单接口继承语法格式</span></span><br><span class="line">child_interface_name <span class="keyword">extends</span> super_interface_name</span><br><span class="line"></span><br><span class="line"><span class="comment">//多接口继承语法格式</span></span><br><span class="line">child_interface_name <span class="keyword">extends</span> super_interface_name1,superinterface_name2,.........</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript基础语法</title>
      <link href="/2022/01/01/typescript-ji-chu-yu-fa-ru-men/"/>
      <url>/2022/01/01/typescript-ji-chu-yu-fa-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="一-基础数据类型"><a href="#一-基础数据类型" class="headerlink" title="一.基础数据类型"></a>一.基础数据类型</h1><table><thead><tr><th>数据类型</th><th>关键字</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>任意类型</td><td>any</td><td>声明为any的变量可以用来表示整数和分数</td><td></td></tr><tr><td>字符串类型</td><td>string</td><td>一个字符系列，使用单引号（’’)或双引号(“”””)来表示字符串类型。反引号（`)来定义多行文本和内嵌表达式</td><td>let num : number = 10;</td></tr><tr><td>布尔类型</td><td>boolean</td><td>表示逻辑值true和false</td><td>let flag : boolean = true</td></tr><tr><td>数组类型</td><td>无</td><td>声明变量为数组</td><td>let arr: number[] =[1,2];</td></tr><tr><td>元组</td><td>无</td><td>元组类型用来表示一直元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同</td><td>let x: [string,number];</td></tr><tr><td>枚举</td><td>enum</td><td>枚举类型用于定义数值集合</td><td>enum Color {Red,Blue}</td></tr><tr><td>void</td><td>void</td><td>用于表示方法返回值类型，表示该方法没有返回值</td><td></td></tr><tr><td>null</td><td>null</td><td>表示对象值缺失</td><td></td></tr><tr><td>undefined</td><td>undefined</td><td>用于初始化变量为一个未定义的值</td><td></td></tr><tr><td>never</td><td>never</td><td>never是其他类型（包括 null 和undefined)的子类型，代表从不会出现的值</td><td></td></tr></tbody></table><h2 id="1-Any类型"><a href="#1-Any类型" class="headerlink" title="1. Any类型"></a>1. Any类型</h2><p>任意值是TypeScript针对编程时类型不明确的变量使用的一种数据类型，它常用于以下三种情况。</p><ol><li>变量的值会动态改变是，比如来自用户的输入，任意类型可以让这些变量跳过编译阶段的类型检查</li></ol><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="number">1</span>;</span><br><span class="line">x = <span class="string">'Is time'</span>;</span><br><span class="line">x = <span class="literal">false</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="2-Null和Undefined"><a href="#2-Null和Undefined" class="headerlink" title="2. Null和Undefined"></a>2. Null和Undefined</h2><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>在 JavaScript 中 null 表示 “”什么都没有””。<br>null是一个只有一个值的特殊类型。表示一个空对象引用。<br>用 type of 检测 null 返回是 object。</p><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>在 JavaScript 中, undefined 是一个没有设置值的变量。</p><p>type of一个没有值的变量会返回 undefined。</p><p>Null 和 Undefined 是其他任何类型（包括 void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。而在TypeScript中启用严格的空校验（–strictNullChecks）特性，就可以使得null 和 undefined 只能被赋值给 void 或本身对应的类型</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启用严格的空校验(--strictNullChecks)</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// 运行正确</span></span><br><span class="line">x = <span class="literal">undefined</span>;    <span class="comment">// 运行错误</span></span><br><span class="line">x = <span class="literal">null</span>;    <span class="comment">// 运行错误</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用 --strictNullChecks</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// 运行正确</span></span><br><span class="line">x = <span class="literal">undefined</span>;    <span class="comment">// 运行正确</span></span><br><span class="line">x = <span class="literal">null</span>;    <span class="comment">// 运行正确</span></span><br></pre></td></tr></tbody></table></figure><h2 id="3-never类型"><a href="#3-never类型" class="headerlink" title="3. never类型"></a>3. never类型</h2><p>never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。这意味着声明为 never 类型的变量只能被 never 类型所赋值，在函数中它通常表现为抛出异常或无法执行到终止点（例如无限循环）</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行错误，数字类型不能转为 never 类型</span></span><br><span class="line">x = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行正确，never 类型可以赋值给 never类型</span></span><br><span class="line">x = (<span class="function">()=&gt;</span>{ <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'exception'</span>)})();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行正确，never 类型可以赋值给 数字类型</span></span><br><span class="line">y = (<span class="function">()=&gt;</span>{ <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'exception'</span>)})();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 never 的函数可以是抛出异常的情况</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 never 的函数可以是无法被执行到的终止点的情况</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loop</span>(<span class="params"></span>): <span class="built_in">never</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="二、TypeScript-变量声明"><a href="#二、TypeScript-变量声明" class="headerlink" title="二、TypeScript 变量声明"></a>二、TypeScript 变量声明</h1><ol><li>声明变量的类型及初始值：</li></ol><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [变量名] : [类型] = 值;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">uname</span>:<span class="built_in">string</span> = <span class="string">""</span>time<span class="string">""</span>;</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>声明变量的类型，但没有初始值，变量值会设置为 undefined：</li></ol><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [变量名]: [类型];</span><br><span class="line"><span class="keyword">var</span> <span class="attr">uname</span>:<span class="built_in">string</span>;</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>声明变量并初始值，但不设置类型，该变量可以是任意类型：</li></ol><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [变量名] = 值;</span><br><span class="line"><span class="keyword">var</span> uname = <span class="string">""</span>time<span class="string">""</span>;</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>声明变量没有设置类型和初始值，类型可以是任意类型，默认初始值为 undefined：</li></ol><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [变量名];</span><br><span class="line"><span class="keyword">var</span> uname;</span><br></pre></td></tr></tbody></table></figure><p><strong>注意</strong>:变量不要使用 name 否则会与 DOM 中的全局 window 对象下的 name 属性出现了重名。</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言可以用来手动指定一个值的类型，即允许变量从一种类型更改为另一种类型。<br>语法格式：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt; 值</span><br></pre></td></tr></tbody></table></figure><p>或</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">值 as 类型</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">str2</span>:<span class="built_in">number</span> = &lt;<span class="built_in">number</span>&gt;&lt;<span class="built_in">any</span>&gt; str <span class="comment">//str、str2是string类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2)</span><br></pre></td></tr></tbody></table></figure><p><em><strong>个人理解</strong></em></p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类型断言不是类型强制转换，而是类型选择。只是在特定地点强制认为该变量的类型为断言类型。</span><br><span class="line">例如：</span><br><span class="line">val变量为联合类型number和string,即val既是number类型，也是string类型，当代码中需要返回val的长度时，val.length就会报错，因为number类型没有length方法。</span><br><span class="line">访问联合类型值的属性时，这个属性必须是所有可能类型的共有属性</span><br></pre></td></tr></tbody></table></figure><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>变量作用域指定了变量定义的位置。</p><p>程序中变量的可用性由变量作用域决定。</p><p>TypeScript 有以下几种作用域：</p><ul><li><strong>全局作用域</strong> ：  全局变量定义在程序结构的外部，它可以在你代码的任何位置使用。</li><li><strong>类作用域</strong>  ：    这个变量也可以称为 字段。类变量声明在一个类里头，但在类的方法外面。 该变量可以通过类的对象来访问。类变量也可以是静态的，静态的变量可以通过类名直接访问。</li><li><strong>局部作用域</strong> ：   局部变量，局部变量只能在声明它的一个代码块（如：方法）中使用。</li></ul><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global_num = <span class="number">12</span>          <span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Numbers</span> { </span><br><span class="line">   num_val = <span class="number">13</span>;             <span class="comment">// 实例变量</span></span><br><span class="line">   <span class="keyword">static</span> sval = <span class="number">10</span>;         <span class="comment">// 静态变量</span></span><br><span class="line">   </span><br><span class="line">   <span class="title function_">storeNum</span>():<span class="built_in">void</span> { </span><br><span class="line">      <span class="keyword">var</span> local_num = <span class="number">14</span>;    <span class="comment">// 局部变量</span></span><br><span class="line">   } </span><br><span class="line">} </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span>全局变量为: <span class="string">""</span>+global_num)  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Numbers</span>.<span class="property">sval</span>)   <span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Numbers</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span>实例变量: <span class="string">""</span>+obj.<span class="property">num_val</span>)</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript函数</title>
      <link href="/2022/01/01/typescript-han-shu/"/>
      <url>/2022/01/01/typescript-han-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript函数"><a href="#TypeScript函数" class="headerlink" title="TypeScript函数"></a><strong>TypeScript函数</strong></h1><p><strong>函数是一组一起执行一个任务的语句。</strong>**<br>**<strong>可以把代码划分到不同的函数中。但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function function_name():return_type { </span><br><span class="line"> &nbsp; &nbsp;// 语句</span><br><span class="line"> &nbsp; &nbsp;return value; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>return_type 是返回值的类型。</strong></li><li><strong>return 关键词后跟着要返回的结果。</strong></li><li><strong>一般情况下，一个函数只有一个 return 语句。</strong></li><li><strong>返回值的类型需要与函数定义的返回类型(return_type)一致。</strong></li></ul><h2 id="带参函数"><a href="#带参函数" class="headerlink" title="带参函数"></a><strong>带参函数</strong></h2><p><strong>在调用函数时，您可以向其传递值，这些值被称为参数。</strong>**<br><strong><strong>这些参数可以在函数中使用。</strong></strong><br>**<strong>您可以向函数发送多个参数，每个参数使用逗号 , 分隔：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function func_name( param1 [:datatype], param2 [:datatype]) { &nbsp; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//示例</span><br><span class="line">function add(x: number, y: number): number {</span><br><span class="line"> &nbsp; &nbsp;return x + y;</span><br><span class="line">}</span><br><span class="line">console.log(add(1,2))</span><br></pre></td></tr></tbody></table></figure><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a><strong>可选参数</strong></h3><p><strong>在 TypeScript 函数里，如果我们定义了参数，则我们必须传入这些参数，除非将这些参数设置为可选，可选参数使用问号标识 ？。</strong>**<br>**<strong>实例</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string, lastName?: string) {</span><br><span class="line"> &nbsp; &nbsp;if (lastName)</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;return firstName + "" "" + lastName;</span><br><span class="line"> &nbsp; &nbsp;else</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;return firstName;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">let result1 = buildName(""Bob""); &nbsp;// 正确</span><br><span class="line">let result2 = buildName(""Bob"", ""Adams"", ""Sr.""); &nbsp;// 错误，参数太多了</span><br><span class="line">let result3 = buildName(""Bob"", ""Adams""); &nbsp;// 正确</span><br></pre></td></tr></tbody></table></figure><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a><strong>默认参数</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function function_name(param1[:type],param2[:type] = default_value) { </span><br><span class="line">}</span><br><span class="line">//示例</span><br><span class="line">function calculate_discount(price, rate) {</span><br><span class="line"> &nbsp; &nbsp;if (rate === void 0) { rate = 0.50; }</span><br><span class="line"> &nbsp; &nbsp;var discount = price * rate;</span><br><span class="line"> &nbsp; &nbsp;console.log(""计算结果: "", discount);</span><br><span class="line">}</span><br><span class="line">calculate_discount(1000);</span><br><span class="line">calculate_discount(1000, 0.30);</span><br></pre></td></tr></tbody></table></figure><h3 id="剩余参数（可变长度参数"><a href="#剩余参数（可变长度参数" class="headerlink" title="剩余参数（可变长度参数)"></a><strong>剩余参数（可变长度参数)</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string, ...restOfName: string[]) {</span><br><span class="line"> &nbsp; &nbsp;return firstName + "" "" + restOfName.join("" "");</span><br><span class="line">}</span><br><span class="line"> &nbsp;</span><br><span class="line">let employeeName = buildName(""Joseph"", ""Samuel"", ""Lucas"", ""MacKinzie"");</span><br></pre></td></tr></tbody></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a><strong>匿名函数</strong></h3><p><strong>匿名函数是一个没有函数名的函数。</strong>**<br><strong><strong>匿名函数在程序运行时动态声明，除了没有函数名外，其他的与标准函数一样。</strong></strong><br>**<strong>我们可以将匿名函数赋值给一个变量，这种表达式就成为函数表达式。</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var res = function([arguments]){...}</span><br><span class="line">//示例 不带参数的匿名函数</span><br><span class="line">var msg = function() { </span><br><span class="line"> &nbsp; &nbsp;return ""hello world""; &nbsp;</span><br><span class="line">} </span><br><span class="line">console.log(msg())</span><br><span class="line"></span><br><span class="line">//带参数的匿名函数</span><br><span class="line">var res = function(a:number,b:number) { </span><br><span class="line"> &nbsp; &nbsp;return a*b; &nbsp;</span><br><span class="line">}; </span><br><span class="line">console.log(res(12,2))</span><br></pre></td></tr></tbody></table></figure><h3 id="匿名函数自调用"><a href="#匿名函数自调用" class="headerlink" title="匿名函数自调用"></a><strong>匿名函数自调用</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function () { </span><br><span class="line"> &nbsp; &nbsp;var x = ""Hello!!""; &nbsp; </span><br><span class="line"> &nbsp; &nbsp;console.log(x) &nbsp; &nbsp; </span><br><span class="line"> })()</span><br></pre></td></tr></tbody></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h3><p>** TypeScript 也支持使用 JavaScript 内置的构造函数 Function() 来定义函数：**</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> var res = new Function ([arg1[, arg2[, ...argN]],] functionBody)</span><br><span class="line"> //参数说明</span><br><span class="line"> //arg1, arg2, ... argN：参数列表。</span><br><span class="line"> //functionBody：一个含有包括函数定义的 JavaScript 语句的字符串。</span><br><span class="line"> </span><br><span class="line"> //示例</span><br><span class="line">var myFunction = new Function(""a"", ""b"", ""return a * b""); </span><br><span class="line">var x = myFunction(4, 3); </span><br><span class="line">console.log(x);</span><br></pre></td></tr></tbody></table></figure><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a><strong>递归函数</strong></h3><p><strong>递归函数即在函数内调用函数本身</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//示例</span><br><span class="line">function factorial(number) {</span><br><span class="line">    if (number &lt;= 0) {         // 停止执行</span><br><span class="line">        return 1; </span><br><span class="line">    } else {   </span><br><span class="line">        return (number * factorial(number - 1));     // 调用自身</span><br><span class="line">    } </span><br><span class="line">}; </span><br><span class="line">console.log(factorial(6));      // 输出 720</span><br></pre></td></tr></tbody></table></figure><h3 id="Lambada函数"><a href="#Lambada函数" class="headerlink" title="Lambada函数"></a><strong>Lambada函数</strong></h3><p><strong>Lambada函数也称之为箭头函数</strong>**<br>**<strong>箭头函数表达式的语法比函数表达式更短</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//语法</span><br><span class="line">( [param1, parma2,…param n] )=&gt;statement;</span><br><span class="line"></span><br><span class="line">//示例</span><br><span class="line">var foo = (x:number) =&gt;10+x</span><br><span class="line">console.log(foo(100))</span><br></pre></td></tr></tbody></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a><strong>函数重载</strong></h3><p><strong>重载是方法名字相同，而参数不同，返回类型可以相同也可以不同。</strong>**<br>**<strong>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TypeScript</span><br><span class="line">function disp(s1:string):void; </span><br><span class="line">function disp(n1:number,s1:string):void; </span><br><span class="line"> </span><br><span class="line">function disp(x:any,y?:any):void { </span><br><span class="line">    console.log(x); </span><br><span class="line">    console.log(y); </span><br><span class="line">} </span><br><span class="line">disp(""abc"") </span><br><span class="line">disp(1,""xyz"");</span><br></pre></td></tr></tbody></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a><strong>元组</strong></h3><p><strong>数组中元素的数据类型都一般是相同的（any[] 类型的数组可以不同），如果存储的元素数据类型不同，则需要使用元组。</strong>**<br>**<strong>元组中允许存储不同类型的元素，元组可以作为参数传递给函数。</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建元组</span><br><span class="line">var tuple_name = [value1,value2,value3...]</span><br><span class="line"></span><br><span class="line">//示例</span><br><span class="line">var mytuple = [10,""tom""]</span><br></pre></td></tr></tbody></table></figure><h4 id="元组运算"><a href="#元组运算" class="headerlink" title="元组运算"></a><strong>元组运算</strong></h4><ul><li><strong>push() 向元组添加元素，添加在最后面</strong></li><li><strong>pop()从元组中移除元素（最后一个),并返回移除的元素</strong></li></ul><h4 id="更新元组"><a href="#更新元组" class="headerlink" title="更新元组"></a><strong>更新元组</strong></h4><p><strong>元组是可变的，所以可对元组进行修改</strong>**<br>**<strong>根据指定的索引更新指定元素</strong></p><h4 id="解构元组"><a href="#解构元组" class="headerlink" title="解构元组"></a><strong>解构元组</strong></h4><p><em><strong><strong>个人理解</strong></strong></em>** 类似于java的顺序取值**</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a =[10,""Runoob""] </span><br><span class="line">var [b,c] = a </span><br><span class="line">console.log( b )  </span><br><span class="line">console.log( c )</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装Nginx</title>
      <link href="/2022/01/01/linux-xia-bu-shu-nginx/"/>
      <url>/2022/01/01/linux-xia-bu-shu-nginx/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux安装Nginx"><a href="#Linux安装Nginx" class="headerlink" title="Linux安装Nginx"></a>Linux安装Nginx</h1><h2 id="安装所需环境"><a href="#安装所需环境" class="headerlink" title="安装所需环境"></a>安装所需环境</h2><ol><li>安装gcc<br>gcc是linux下的编译器，它可以编译 C,C++,Ada,Object C和Java等语言</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></tbody></table></figure><p>如果没安装会提示命令找不到</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>pcre、pcre-devel安装<br>pcre是一个perl库，包括perl兼容的正则表达式库，nginx的http模块使用pcre来解析正则表达式，所以需要安装pcre库。</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>zlib安装<br>zlib库提供了很多种压缩和解压缩方式nginx使用zlib对http包的内容进行gzip</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>安装openssl<br>openssl是web安全通信的基石，没有openssl，可以说我们的信息都是在裸奔</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></tbody></table></figure><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><ol><li>下载nginx安装包</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.18.0.tar.gz</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>把压缩包解压到/usr/local</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.18.0.tar.gz</span><br><span class="line">mv nginx-1.18.0 /usr/local/</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>切换到解压目录</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx-1.18.0</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>切换到安装目录</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>配置nginx的配置文件nginx.conf</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim conf/nginx.conf</span><br></pre></td></tr></tbody></table></figure><p>为了不污染主配置文件，添加include vhost/*.conf;</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http{</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">include  vhost/*.conf;</span><br><span class="line">....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="6"><li>启动nginx服务<br>切换到目录/usr/local/nginx/sbin下</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx</span><br></pre></td></tr></tbody></table></figure><ol start="7"><li>查看nginx服务是否成功启动</li><li>设置nginx开机自启动</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim  /etc/init.d/nginx </span><br></pre></td></tr></tbody></table></figure><p>内容如下：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/bash</span></span><br><span class="line"><span class="comment"># chkconfig: - 85 15</span></span><br><span class="line"><span class="attr">PATH</span>=<span class="string">/usr/local/nginx       ###这里是你安装的路径，替换成自己安装的路径</span></span><br><span class="line"><span class="attr">DESC</span>=<span class="string">""nginx daemon""</span></span><br><span class="line"><span class="attr">NAME</span>=<span class="string">nginx</span></span><br><span class="line"><span class="attr">DAEMON</span>=<span class="string">$PATH/sbin/$NAME</span></span><br><span class="line"><span class="attr">CONFIGFILE</span>=<span class="string">$PATH/conf/$NAME.conf</span></span><br><span class="line"><span class="attr">PIDFILE</span>=<span class="string">$PATH/logs/$NAME.pid</span></span><br><span class="line"><span class="attr">SCRIPTNAME</span>=<span class="string">/etc/init.d/$NAME</span></span><br><span class="line"><span class="attr">set</span> <span class="string">-e</span></span><br><span class="line"><span class="attr">[</span> <span class="string">-x ""$DAEMON"" ] || exit 0</span></span><br><span class="line"><span class="attr">do_start()</span> <span class="string">{</span></span><br><span class="line"><span class="attr">$DAEMON</span> <span class="string">-c $CONFIGFILE || echo -n ""nginx already running""</span></span><br><span class="line"><span class="attr">}</span></span><br><span class="line"><span class="attr">do_stop()</span> <span class="string">{</span></span><br><span class="line"><span class="attr">$DAEMON</span> <span class="string">-s stop || echo -n ""nginx not running""</span></span><br><span class="line"><span class="attr">}</span></span><br><span class="line"><span class="attr">do_reload()</span> <span class="string">{</span></span><br><span class="line"><span class="attr">$DAEMON</span> <span class="string">-s reload || echo -n ""nginx can't reload""</span></span><br><span class="line"><span class="attr">}</span></span><br><span class="line"><span class="attr">case</span> <span class="string">""$1"" in</span></span><br><span class="line"><span class="attr">start)</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">-n ""Starting $DESC: $NAME""</span></span><br><span class="line"><span class="attr">do_start</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">"".""</span></span><br><span class="line"><span class="attr">;;</span></span><br><span class="line"><span class="attr">stop)</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">-n ""Stopping $DESC: $NAME""</span></span><br><span class="line"><span class="attr">do_stop</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">"".""</span></span><br><span class="line"><span class="attr">;;</span></span><br><span class="line"><span class="attr">reload|graceful)</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">-n ""Reloading $DESC configuration...""</span></span><br><span class="line"><span class="attr">do_reload</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">"".""</span></span><br><span class="line"><span class="attr">;;</span></span><br><span class="line"><span class="attr">restart)</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">-n ""Restarting $DESC: $NAME""</span></span><br><span class="line"><span class="attr">do_stop</span></span><br><span class="line"><span class="attr">do_start</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">"".""</span></span><br><span class="line"><span class="attr">;;</span></span><br><span class="line"><span class="attr">*)</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">""Usage: $SCRIPTNAME {start|stop|reload|restart}"" &gt;&amp;2</span></span><br><span class="line"><span class="attr">exit</span> <span class="string">3</span></span><br><span class="line"><span class="attr">;;</span></span><br><span class="line"><span class="attr">esac</span></span><br><span class="line"><span class="attr">exit</span> <span class="string">0</span></span><br></pre></td></tr></tbody></table></figure><ol start="9"><li>加入系统设置开机自启动</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/rc.d/init.d/nginx #（设置可执行权限）</span><br><span class="line"></span><br><span class="line">chkconfig --add nginx #（添加系统服务）</span><br><span class="line"></span><br><span class="line">chkconfig --level 35 nginx on #（开机自启动）</span><br></pre></td></tr></tbody></table></figure><p>可以使用</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl   start nginx  #启动 </span><br><span class="line">systemctl   stop nginx   #关闭</span><br></pre></td></tr></tbody></table></figure><p>nginx.conf说明</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attr">worker_processes</span>  <span class="string">1; #工作进程：数目。根据硬件调整，通常等于cpu数量或者2倍cpu数量。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">#错误日志存放路径</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid; # nginx进程pid存放路径</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="attr">events</span> <span class="string">{</span></span><br><span class="line">    <span class="attr">worker_connections</span>  <span class="string">1024; # 工作进程的最大连接数量</span></span><br><span class="line"><span class="attr">}</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="attr">http</span> <span class="string">{</span></span><br><span class="line">    <span class="attr">include</span>       <span class="string">mime.types; #指定mime类型，由mime.type来定义</span></span><br><span class="line">    <span class="attr">default_type</span>  <span class="string">application/octet-stream;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    # 日志格式设置</span></span><br><span class="line"><span class="comment">    #log_format  main  '$remote_addr - $remote_user [$time_local] ""$request"" '</span></span><br><span class="line"><span class="comment">    #                  '$status $body_bytes_sent ""$http_referer"" '</span></span><br><span class="line"><span class="comment">    #                  '""$http_user_agent"" ""$http_x_forwarded_for""';</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #access_log  logs/access.log  main; #用log_format指令设置日志格式后，需要用access_log来指定日志文件存放路径</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">sendfile</span>        <span class="string">on; #指定nginx是否调用sendfile函数来输出文件，对于普通应用，必须设置on。</span></span><br><span class="line"><span class="attr">如果用来进行下载等应用磁盘io重负载应用，可设着off，以平衡磁盘与网络io处理速度，降低系统uptime。</span></span><br><span class="line"><span class="comment">    #tcp_nopush     on; #此选项允许或禁止使用socket的TCP_CORK的选项，此选项仅在sendfile的时候使用</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #keepalive_timeout  0;  #keepalive超时时间</span></span><br><span class="line">    <span class="attr">keepalive_timeout</span>  <span class="string">65;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #gzip  on; #开启gzip压缩服务</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #虚拟主机</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">{</span></span><br><span class="line">        <span class="attr">listen</span>       <span class="string">80;  #配置监听端口号</span></span><br><span class="line">        <span class="attr">server_name</span>  <span class="string">localhost; #配置访问域名，域名可以有多个，用空格隔开</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">        #charset koi8-r; #字符集设置</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">        #access_log  logs/host.access.log  main;</span></span><br><span class="line"> </span><br><span class="line">        <span class="attr">location</span> <span class="string">/ {</span></span><br><span class="line">            <span class="attr">root</span>   <span class="string">html;</span></span><br><span class="line">            <span class="attr">index</span>  <span class="string">index.html index.htm;</span></span><br><span class="line">        <span class="attr">}</span></span><br><span class="line"><span class="comment">        #错误跳转页</span></span><br><span class="line"><span class="comment">        #error_page  404              /404.html; </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">        # redirect server error pages to the static page /50x.html</span></span><br><span class="line"><span class="comment">        #</span></span><br><span class="line">        <span class="attr">error_page</span>   <span class="string">500 502 503 504  /50x.html;</span></span><br><span class="line">        <span class="attr">location</span> = <span class="string">/50x.html {</span></span><br><span class="line">            <span class="attr">root</span>   <span class="string">html;</span></span><br><span class="line">        <span class="attr">}</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line"><span class="comment">        #</span></span><br><span class="line"><span class="comment">        #location ~ \.php$ {</span></span><br><span class="line"><span class="comment">        #    proxy_pass   http://127.0.0.1;</span></span><br><span class="line"><span class="comment">        #}</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line"><span class="comment">        #</span></span><br><span class="line"><span class="comment">        #location ~ \.php$ { #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span></span><br><span class="line"><span class="comment">        #    root           html; #根目录</span></span><br><span class="line"><span class="comment">        #    fastcgi_pass   127.0.0.1:9000; #请求转向定义的服务器列表</span></span><br><span class="line"><span class="comment">        #    fastcgi_index  index.php; # 如果请求的Fastcgi_index URI是以 / 结束的, 该指令设置的文件会被附加到URI的后面并保存在变量$fastcig_script_name中</span></span><br><span class="line"><span class="comment">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line"><span class="comment">        #    include        fastcgi_params;</span></span><br><span class="line"><span class="comment">        #}</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">        # deny access to .htaccess files, if Apache's document root</span></span><br><span class="line"><span class="comment">        # concurs with nginx's one</span></span><br><span class="line"><span class="comment">        #</span></span><br><span class="line"><span class="comment">        #location ~ /\.ht {</span></span><br><span class="line"><span class="comment">        #    deny  all;</span></span><br><span class="line"><span class="comment">        #}</span></span><br><span class="line">    <span class="attr">}</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    # another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class="line"><span class="comment">    #</span></span><br><span class="line"><span class="comment">    #server {</span></span><br><span class="line"><span class="comment">    #    listen       8000;</span></span><br><span class="line"><span class="comment">    #    listen       somename:8080;</span></span><br><span class="line"><span class="comment">    #    server_name  somename  alias  another.alias;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #    location / {</span></span><br><span class="line"><span class="comment">    #        root   html;</span></span><br><span class="line"><span class="comment">    #        index  index.html index.htm;</span></span><br><span class="line"><span class="comment">    #    }</span></span><br><span class="line"><span class="comment">    #}</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    # HTTPS server</span></span><br><span class="line"><span class="comment">    #</span></span><br><span class="line"><span class="comment">    #server {</span></span><br><span class="line"><span class="comment">    #    listen       443 ssl;  #监听端口</span></span><br><span class="line"><span class="comment">    #    server_name  localhost; #域名</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #    ssl_certificate      cert.pem; #证书位置</span></span><br><span class="line"><span class="comment">    #    ssl_certificate_key  cert.key; #私钥位置</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line"><span class="comment">    #    ssl_session_timeout  5m; </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #    ssl_ciphers  HIGH:!aNULL:!MD5; #密码加密方式</span></span><br><span class="line"><span class="comment">    #    ssl_prefer_server_ciphers  on; # ssl_prefer_server_ciphers  on; #</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #    location / {</span></span><br><span class="line"><span class="comment">    #        root   html;</span></span><br><span class="line"><span class="comment">    #        index  index.html index.htm;</span></span><br><span class="line"><span class="comment">    #    }</span></span><br><span class="line"><span class="comment">    #}</span></span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 环境搭建 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL安装</title>
      <link href="/2022/01/01/mysql-an-zhuang/"/>
      <url>/2022/01/01/mysql-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h1><h2 id="MySQL在线下载安装"><a href="#MySQL在线下载安装" class="headerlink" title="MySQL在线下载安装"></a>MySQL在线下载安装</h2><p>注：需要连接互联网，在线mysql的安装包，5.6的版本大约86M</p><ol><li><p>查看CentOS是否自带的MySQL，如果已经安装需要卸载。如果没有找到，则表示没有安装。</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></tbody></table></figure></li><li><p>在线获取CentOS7的mysql的rpm安装文件，直接执行如下命令</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这条语句只是下载了一个rpm文件，25K大小</p></blockquote></li><li><p>执行安装命令</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql80-community-release-el7-1.noarch.rpm</span><br></pre></td></tr></tbody></table></figure></li><li><p>得到两个配置文件，在/etc/yum.repos.d目录下。</p><ul><li>mysql-community.repo用于指定下载哪个版本的安装包</li><li>mysql-community-source.repo用于指定下载哪个版本的源码</li></ul></li><li><p>修改MySQL的下载配置文件</p><ul><li>vim /etc/yum.repos.d/mysql-community.repo</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Enable to use MySQL 5.6</span><br><span class="line">[mysql56-community]</span><br><span class="line">name=MySQL 5.6 Community Server</span><br><span class="line">baseurl=http://repo.mysq.com/yum/mysql-5.6-community/el/7/$baseurl/</span><br><span class="line"># 设置为1，表示下载</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[mysql80-community]</span><br><span class="line">name=MySQL 8.0 Community Server</span><br><span class="line">baseurl=http://repo.mysq.com/yum/mysql-8.0-community/el/7/$baseurl/</span><br><span class="line"># 设置为0，表示不下载</span><br><span class="line">enabled=0</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br></pre></td></tr></tbody></table></figure></li><li><p>在当前目录/etc/yum.repos.d下执行下面的命令，开始在线下载：客户端，服务器端，开发的工具包。</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mysql-community-client mysql-community-server mysql-community-devel</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这里需要比较长的时间，要从互联网上下载86M左右的内容</p></blockquote></li><li><p>使用rpm命令，可以查询到mysql已经安装好的包</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="修改mysql底层码表"><a href="#修改mysql底层码表" class="headerlink" title="修改mysql底层码表"></a>修改mysql底层码表</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>由于mysql软件底层码表使用的不是utf-8，导致执行sql语句中文乱码。需要设置客户端和服务器端的编码为utf-8</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p>修改mysql的配置文件</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> Linux命令</span><br><span class="line">vim /etc/my.cnf</span><br></pre></td></tr></tbody></table></figure></li><li><p>在mysqld条目下增加以下配置，指定服务器的字符集为utf-8</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line">character-set-server=utf8 </span><br></pre></td></tr></tbody></table></figure></li><li><p>增加客户端的默认字符集的配置，指定为utf-8，将下面的配置放到文件的结尾处</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line"></span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></tbody></table></figure></li><li><p>文件保存退出后，重启mysql服务</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="启动MySQL服务并登录"><a href="#启动MySQL服务并登录" class="headerlink" title="启动MySQL服务并登录"></a>启动MySQL服务并登录</h2><ol><li><p>启动mysql的服务</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> Linux命令</span><br><span class="line">systemctl start mysqld</span><br></pre></td></tr></tbody></table></figure></li><li><p>将mysql加到系统服务中并设置开机启动</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> Linux命令</span><br><span class="line">systemctl enable mysqld</span><br></pre></td></tr></tbody></table></figure></li><li><p>登录mysql，root用户默认没有密码</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> Linux命令</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></tbody></table></figure></li><li><p>在mysql中修改自己的密码</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> MySQL命令</span><br><span class="line">set password = password('密码'); </span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="设置远程访问权限"><a href="#设置远程访问权限" class="headerlink" title="设置远程访问权限"></a>设置远程访问权限</h2><blockquote><p>开启mysql的远程登录权限，默认情况下mysql为安全起见，不支持远程登录mysql，所以需要设置开启，并且刷新权限缓存。</p></blockquote><ol><li><p>远程登录mysql的权限登录mysql后输入如下命令</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> MySQL命令</span><br><span class="line">grant all privileges on *.* to 'root'@'<span class="comment">%' identified by '自己设置密码';</span></span><br><span class="line">flush privileges;</span><br></pre></td></tr></tbody></table></figure></li><li><p>开放Linux的对外访问的端口3306</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> Linux命令</span><br><span class="line"><span class="params">#</span>开放3306端口</span><br><span class="line">/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="params">#</span>开放的端口永久保存到防火墙</span><br><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="params">#</span>重启防火墙</span><br><span class="line">systemctl restart firewalld</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="客户端Windows连接MySQL"><a href="#客户端Windows连接MySQL" class="headerlink" title="客户端Windows连接MySQL"></a>客户端Windows连接MySQL</h2><p>在本地Windows系统使用Navicat Premium软件连接虚拟机中的Linux系统安装的MySQL</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> Linux </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux安装redis</title>
      <link href="/2022/01/01/linux-an-zhuang-redis/"/>
      <url>/2022/01/01/linux-an-zhuang-redis/</url>
      
        <content type="html"><![CDATA[<h1 id="linux安装redis"><a href="#linux安装redis" class="headerlink" title="linux安装redis"></a>linux安装redis</h1><h2 id="一、进入redis官网寻找要下载的版本：https-redis-io"><a href="#一、进入redis官网寻找要下载的版本：https-redis-io" class="headerlink" title="一、进入redis官网寻找要下载的版本：https://redis.io/"></a>一、进入redis官网寻找要下载的版本：<a href="https://redis.io/">https://redis.io/</a></h2><p>将下载地址链接复制下来： <a href="http://download.redis.io/releases/redis-6.0.5.tar.gz">http://download.redis.io/releases/redis-6.0.5.tar.gz</a></p><h2 id="二、在线下载redis"><a href="#二、在线下载redis" class="headerlink" title="二、在线下载redis"></a>二、在线下载redis</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">wget  http://download.redis.io/releases/redis-6.0.5.tar.gz</span><br></pre></td></tr></tbody></table></figure><p>下载完成之后解压安装包并执行安装测试</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar xzf redis-6.0.5.tar.gz</span><br><span class="line">cd redis-6.0.5</span><br><span class="line">make test</span><br></pre></td></tr></tbody></table></figure><p>如果出现</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh: cc: command not found </span><br></pre></td></tr></tbody></table></figure><p>则执行如下命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install gcc gcc-c++ libstdc++-devel </span><br><span class="line">make MALLOC=libc</span><br></pre></td></tr></tbody></table></figure><p>如果出现</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">server.c: 在函数‘iAmMaster’中: server.c:4964:1: 警告:在有返回值的函数中,控制流程到达函数尾 [-Wreturn-type]</span><br><span class="line">....</span><br></pre></td></tr></tbody></table></figure><p>则系统gcc版本太低<br>解决gcc版本过低问题<br>安装scl源</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br></pre></td></tr></tbody></table></figure><p>列出scl可用源</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list all --enablerepo='centos-sclo-rh'</span><br></pre></td></tr></tbody></table></figure><p>安装8版本的gcc、gcc-c++、gdb工具链（toolchian）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y devtoolset-8-toolchain</span><br><span class="line">scl enable devtoolset-8 bash</span><br><span class="line">gcc --version</span><br></pre></td></tr></tbody></table></figure><h2 id="三、安装Redis"><a href="#三、安装Redis" class="headerlink" title="三、安装Redis"></a>三、安装Redis</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></tbody></table></figure><p>启动Redis</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></tbody></table></figure><p>如果报如下错误，则根据提示修改以下内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sysctl vm.overcommit_memory=1</span><br><span class="line">echo 511 &gt; /proc/sys/net/core/somaxconn</span><br><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line">redis-server</span><br></pre></td></tr></tbody></table></figure><h2 id="四、配置"><a href="#四、配置" class="headerlink" title="四、配置"></a>四、配置</h2><p>修改安装目录下的redis.conf文件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/local/redis-6.0.5/redis.conf </span><br></pre></td></tr></tbody></table></figure><p>修改以下配置：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">bind</span> 127.0.0.1 <span class="comment"># 将这行代码注释，监听所有的ip地址，外网可以访问</span></span></span><br><span class="line">protected-mode no # 把yes改成no，允许外网访问</span><br><span class="line">daemonize yes # 把no改成yes，后台运行</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">找到如下行：<span class="comment">#requirepass foobared，并改为</span></span></span><br><span class="line">requirepass XXXXXX （其中XXXXXX就是要设置的密码）</span><br></pre></td></tr></tbody></table></figure><h2 id="五、启动或停止"><a href="#五、启动或停止" class="headerlink" title="五、启动或停止"></a>五、启动或停止</h2><p>redis提供了服务端命令和客户端命令：</p><ul><li>redis-server 服务端命令，可以包含以下参数：<br>start 启动<br>stop 停止</li><li>redis-cli 客户端控制台，包含参数：<br>-h xxx 指定服务端地址，缺省值是127.0.0.1<br>-p xxx 指定服务端端口，缺省值是6379</li></ul><h2 id="六、设置开机启动"><a href="#六、设置开机启动" class="headerlink" title="六、设置开机启动"></a>六、设置开机启动</h2><ol><li>输入命令，新建文件</li></ol><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/init.d/redis</span><br></pre></td></tr></tbody></table></figure><p>输入下面内容：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># chkconfig:   2345 90 10</span></span><br><span class="line"><span class="comment"># description:  Redis is a persistent key-value database</span></span><br><span class="line">PATH=/usr/local/bin:/sbin:/usr/bin:/bin</span><br><span class="line"></span><br><span class="line">REDISPORT=6379</span><br><span class="line">EXEC=/usr/local/bin/redis-server</span><br><span class="line">REDIS_CLI=/usr/local/bin/redis-cli</span><br><span class="line"></span><br><span class="line">PIDFILE=/var/run/redis.pid</span><br><span class="line"></span><br><span class="line">CONF=<span class="string">""</span>/usr/local/redis-6.0.5/redis.conf<span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">""</span><span class="variable">$1</span><span class="string">""</span> <span class="keyword">in</span>  </span><br><span class="line">    start)  </span><br><span class="line">        <span class="keyword">if</span> [ -f <span class="variable">$PIDFILE</span> ]  </span><br><span class="line">        <span class="keyword">then</span>  </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">""</span><span class="variable">$PIDFILE</span> exists, process is already running or crashed<span class="string">""</span>  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">""</span>Starting Redis server...<span class="string">""</span>  </span><br><span class="line">                <span class="variable">$EXEC</span> <span class="variable">$CONF</span>  </span><br><span class="line">        <span class="keyword">fi</span>  </span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">""</span>$?<span class="string">""</span>=<span class="string">""</span>0<span class="string">""</span> ]   </span><br><span class="line">        <span class="keyword">then</span>  </span><br><span class="line">              <span class="built_in">echo</span> <span class="string">""</span>Redis is running...<span class="string">""</span>  </span><br><span class="line">        <span class="keyword">fi</span>  </span><br><span class="line">        ;;  </span><br><span class="line">    stop)  </span><br><span class="line">        <span class="keyword">if</span> [ ! -f <span class="variable">$PIDFILE</span> ]  </span><br><span class="line">        <span class="keyword">then</span>  </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">""</span><span class="variable">$PIDFILE</span> does not exist, process is not running<span class="string">""</span>  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">                PID=$(<span class="built_in">cat</span> <span class="variable">$PIDFILE</span>)  </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">""</span>Stopping ...<span class="string">""</span>  </span><br><span class="line">                <span class="variable">$REDIS_CLI</span> -p <span class="variable">$REDISPORT</span> SHUTDOWN  </span><br><span class="line">                <span class="keyword">while</span> [ -x <span class="variable">${PIDFILE}</span> ]  </span><br><span class="line">               <span class="keyword">do</span>  </span><br><span class="line">                    <span class="built_in">echo</span> <span class="string">""</span>Waiting <span class="keyword">for</span> Redis to shutdown ...<span class="string">""</span>  </span><br><span class="line">                    <span class="built_in">sleep</span> 1  </span><br><span class="line">                <span class="keyword">done</span>  </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">""</span>Redis stopped<span class="string">""</span>  </span><br><span class="line">        <span class="keyword">fi</span>  </span><br><span class="line">        ;;  </span><br><span class="line">   restart|force-reload)  </span><br><span class="line">        <span class="variable">${0}</span> stop  </span><br><span class="line">        <span class="variable">${0}</span> start  </span><br><span class="line">        ;;  </span><br><span class="line">  *)  </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">""</span>Usage: /etc/init.d/redis {start|stop|restart|force-reload}<span class="string">""</span> &gt;&amp;2  </span><br><span class="line">        <span class="built_in">exit</span> 1  </span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>然后保存退出</p><p>注意：以下信息需要根据安装目录进行调整：</p><blockquote><p>EXEC=/usr/local/bin/redis-server # 执行脚本的地址</p><p>REDIS_CLI=/usr/local/bin/redis-cli # 客户端执行脚本的地址</p><p>PIDFILE=/var/run/redis.pid # 进程id文件地址</p><p>CONF=””/usr/local/src/redis-3.0.2/redis.conf”” #配置文件地址</p></blockquote><ol start="2"><li>设置权限</li></ol><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 755 /etc/init.d/redis</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>启动测试</li></ol><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/redis start</span><br></pre></td></tr></tbody></table></figure><p>启动成功会提示如下信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Starting Redis server...</span><br><span class="line">Redis is running...</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>设置开机自启动</li></ol><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chkconfig --add /etc/init.d/redis</span><br><span class="line">sudo chkconfig redis on</span><br></pre></td></tr></tbody></table></figure><p>“</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> Linux </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装JDK1.8</title>
      <link href="/2022/01/01/linux-an-zhuang-jdk1.8/"/>
      <url>/2022/01/01/linux-an-zhuang-jdk1.8/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux安装JDK1-8"><a href="#Linux安装JDK1-8" class="headerlink" title="Linux安装JDK1.8"></a>Linux安装JDK1.8</h1><h2 id="1、检查系统中的jdk版本"><a href="#1、检查系统中的jdk版本" class="headerlink" title="1、检查系统中的jdk版本"></a>1、检查系统中的jdk版本</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></tbody></table></figure><h2 id="2、检测jdk安装包"><a href="#2、检测jdk安装包" class="headerlink" title="2、检测jdk安装包"></a>2、检测jdk安装包</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java</span><br></pre></td></tr></tbody></table></figure><h2 id="3、卸载openjdk"><a href="#3、卸载openjdk" class="headerlink" title="3、卸载openjdk"></a>3、卸载openjdk</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps xxxxxxx</span><br></pre></td></tr></tbody></table></figure><p>或者</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove *openjdk*</span><br></pre></td></tr></tbody></table></figure><h2 id="4、安装新的jdk"><a href="#4、安装新的jdk" class="headerlink" title="4、安装新的jdk"></a>4、安装新的jdk</h2><p>首先到jdk官网上下载你想要的jdk版本。官网由于证书问题wget 不能直接下载，需要加忽略证书和请求头。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate --no-cookies --header ""Cookie: oraclelicense=accept-securebackup-cookie"" http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.rpm</span><br></pre></td></tr></tbody></table></figure><p>添加执行权限：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x jdk-8u131-linux-x64.rpm </span><br></pre></td></tr></tbody></table></figure><p>执行rpm进行安装</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh jdk-8u131-linux-x64.rpm</span><br></pre></td></tr></tbody></table></figure><p>查看JDK是否安装成功</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></tbody></table></figure><p>查看JDK的安装路径，（一般默认的路径：/usr/java/jdk1.8.0_131）<br>移动到/usr/local下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/java /usr/loacl</span><br></pre></td></tr></tbody></table></figure><ol><li><p>配置jdk环境变量，打开/etc/profile配置文件，将下面配置拷贝进去。export命令用于将shell变量输出为环境变量。</p><p>注：在linux下以冒号分隔不同的路径，而windows下是分号。</p><p>注：引用变量在linux下是$变量名, 在windows下是%变量名%</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></tbody></table></figure></li></ol><ul><li><p>/etc/profile</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span>set java environment</span><br><span class="line">JAVA<span class="built_in">_</span>HOME=/usr/local/jdk1.8.0<span class="built_in">_</span>211</span><br><span class="line">CLASSPATH=.:<span class="built_in">$</span>JAVA<span class="built_in">_</span>HOME/lib</span><br><span class="line">PATH=<span class="built_in">$</span>JAVA<span class="built_in">_</span>HOME/bin:<span class="built_in">$</span>PATH</span><br><span class="line">export JAVA<span class="built_in">_</span>HOME CLASSPATH PATH</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="3"><li><p>重新加载/etc/profile配置文件，并测试</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></tbody></table></figure></li><li><p>判断JDK是否安装成功</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">javac -version</span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> Linux </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
