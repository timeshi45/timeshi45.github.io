<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript字符串&#39;</title>
      <link href="/2022/05/20/javascript-zi-fu-chuan/"/>
      <url>/2022/05/20/javascript-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h1>字符串</h1><h2 id="概述">概述</h2><h3 id="定义">定义</h3><p>字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span></span><br><span class="line"><span class="string">"abc"</span></span><br></pre></td></tr></tbody></table></figure><p>单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'key = "value"'</span></span><br><span class="line"><span class="string">"It's a long journey"</span></span><br></pre></td></tr></tbody></table></figure><p>上面两个都是合法的字符串。</p><p>如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Did she say \'Hello\'?'</span></span><br><span class="line"><span class="comment">// "Did she say 'Hello'?"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"Did she say \"Hello\"?"</span></span><br><span class="line"><span class="comment">// "Did she say "Hello"?"</span></span><br></pre></td></tr></tbody></table></figure><p>由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号，本教程遵守这个约定。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。</p><p>字符串默认只能写在一行内，分成多行将会报错。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">c'</span></span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token ILLEGAL</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码将一个字符串分成三行，JavaScript 就会报错。</p><p>如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longString = <span class="string">'Long \</span></span><br><span class="line"><span class="string">long \</span></span><br><span class="line"><span class="string">long \</span></span><br><span class="line"><span class="string">string'</span>;</span><br><span class="line"></span><br><span class="line">longString</span><br><span class="line"><span class="comment">// "Long long long string"</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。</p><p>连接运算符（<code>+</code>）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longString = <span class="string">'Long '</span></span><br><span class="line">  + <span class="string">'long '</span></span><br><span class="line">  + <span class="string">'long '</span></span><br><span class="line">  + <span class="string">'string'</span>;</span><br></pre></td></tr></tbody></table></figure><p>如果想输出多行字符串，有一种利用多行注释的变通方法。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) { <span class="comment">/*</span></span><br><span class="line"><span class="comment">line 1</span></span><br><span class="line"><span class="comment">line 2</span></span><br><span class="line"><span class="comment">line 3</span></span><br><span class="line"><span class="comment">*/</span>}).<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">'\n'</span>).<span class="title function_">slice</span>(<span class="number">1</span>, -<span class="number">1</span>).<span class="title function_">join</span>(<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">// "line 1</span></span><br><span class="line"><span class="comment">// line 2</span></span><br><span class="line"><span class="comment">// line 3"</span></span><br></pre></td></tr></tbody></table></figure><p>上面的例子中，输出的字符串就是多行。</p><h3 id="转义">转义</h3><p>反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。</p><p>需要用反斜杠转义的特殊字符，主要有下面这些。</p><ul><li><code>\0</code> ：null（<code>\u0000</code>）</li><li><code>\b</code> ：后退键（<code>\u0008</code>）</li><li><code>\f</code> ：换页符（<code>\u000C</code>）</li><li><code>\n</code> ：换行符（<code>\u000A</code>）</li><li><code>\r</code> ：回车键（<code>\u000D</code>）</li><li><code>\t</code> ：制表符（<code>\u0009</code>）</li><li><code>\v</code> ：垂直制表符（<code>\u000B</code>）</li><li><code>\'</code> ：单引号（<code>\u0027</code>）</li><li><code>\"</code> ：双引号（<code>\u0022</code>）</li><li><code>\\</code> ：反斜杠（<code>\u005C</code>）</li></ul><p>上面这些字符前面加上反斜杠，都表示特殊含义。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'1\n2'</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，<code>\n</code>表示换行，输出的时候就分成了两行。</p><p>反斜杠还有三种特殊用法。</p><p>（1）<code>\HHH</code></p><p>反斜杠后面紧跟三个八进制数（<code>000</code>到<code>377</code>），代表一个字符。<code>HHH</code>对应该字符的 Unicode 码点，比如<code>\251</code>表示版权符号。显然，这种方法只能输出256种字符。</p><p>（2）<code>\xHH</code></p><p><code>\x</code>后面紧跟两个十六进制数（<code>00</code>到<code>FF</code>），代表一个字符。<code>HH</code>对应该字符的 Unicode 码点，比如<code>\xA9</code>表示版权符号。这种方法也只能输出256种字符。</p><p>（3）<code>\uXXXX</code></p><p><code>\u</code>后面紧跟四个十六进制数（<code>0000</code>到<code>FFFF</code>），代表一个字符。<code>XXXX</code>对应该字符的 Unicode 码点，比如<code>\u00A9</code>表示版权符号。</p><p>下面是这三种字符特殊写法的例子。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\251'</span> <span class="comment">// "©"</span></span><br><span class="line"><span class="string">'\xA9'</span> <span class="comment">// "©"</span></span><br><span class="line"><span class="string">'\u00A9'</span> <span class="comment">// "©"</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\172'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\x7A'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u007A'</span> === <span class="string">'z'</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\a'</span></span><br><span class="line"><span class="comment">// "a"</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，<code>a</code>是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。</p><p>如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Prev \\ Next"</span></span><br><span class="line"><span class="comment">// "Prev \ Next"</span></span><br></pre></td></tr></tbody></table></figure><h3 id="字符串与数组">字符串与数组</h3><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line">s[<span class="number">0</span>] <span class="comment">// "h"</span></span><br><span class="line">s[<span class="number">1</span>] <span class="comment">// "e"</span></span><br><span class="line">s[<span class="number">4</span>] <span class="comment">// "o"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接对字符串使用方括号运算符</span></span><br><span class="line"><span class="string">'hello'</span>[<span class="number">1</span>] <span class="comment">// "e"</span></span><br></pre></td></tr></tbody></table></figure><p>如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>[<span class="number">3</span>] <span class="comment">// undefined</span></span><br><span class="line"><span class="string">'abc'</span>[-<span class="number">1</span>] <span class="comment">// undefined</span></span><br><span class="line"><span class="string">'abc'</span>[<span class="string">'x'</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></tbody></table></figure><p>但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> s[<span class="number">0</span>];</span><br><span class="line">s <span class="comment">// "hello"</span></span><br><span class="line"></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">'a'</span>;</span><br><span class="line">s <span class="comment">// "hello"</span></span><br><span class="line"></span><br><span class="line">s[<span class="number">5</span>] = <span class="string">'!'</span>;</span><br><span class="line">s <span class="comment">// "hello"</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。</p><h3 id="length-属性">length 属性</h3><p><code>length</code>属性返回字符串的长度，该属性也是无法改变的。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line">s.<span class="property">length</span> <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">s.<span class="property">length</span> = <span class="number">3</span>;</span><br><span class="line">s.<span class="property">length</span> <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">s.<span class="property">length</span> = <span class="number">7</span>;</span><br><span class="line">s.<span class="property">length</span> <span class="comment">// 5</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码表示字符串的<code>length</code>属性无法改变，但是不会报错。</p><h2 id="字符集">字符集</h2><p>JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。</p><p>JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成<code>\uxxxx</code>的形式，其中<code>xxxx</code>代表该字符的 Unicode 码点。比如，<code>\u00A9</code>代表版权符号。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'\u00A9'</span>;</span><br><span class="line">s <span class="comment">// "©"</span></span><br></pre></td></tr></tbody></table></figure><p>解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f\u006F\u006F = <span class="string">'abc'</span>;</span><br><span class="line">foo <span class="comment">// "abc"</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，第一行的变量名<code>foo</code>是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。</p><p>我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。</p><p>但是，UTF-16 有两种长度：对于码点在<code>U+0000</code>到<code>U+FFFF</code>之间的字符，长度为16位（即2个字节）；对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，长度为32位（即4个字节），而且前两个字节在<code>0xD800</code>到<code>0xDBFF</code>之间，后两个字节在<code>0xDC00</code>到<code>0xDFFF</code>之间。举例来说，码点<code>U+1D306</code>对应的字符为<code>𝌆，</code>它写成 UTF-16 就是<code>0xD834 0xDF06</code>。</p><p>JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到<code>U+FFFF</code>，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符<code>𝌆</code>，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'𝌆'</span>.<span class="property">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，JavaScript 认为<code>𝌆</code>的长度为2，而不是1。</p><p>总结一下，对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，JavaScript 总是认为它们是两个字符（<code>length</code>属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。</p><h2 id="Base64-转码">Base64 转码</h2><p>有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。</p><p>所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、<code>+</code>和<code>/</code>这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</p><p>JavaScript 原生提供两个 Base64 相关的方法。</p><ul><li><code>btoa()</code>：任意值转为 Base64 编码</li><li><code>atob()</code>：Base64 编码转为原来的值</li></ul><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">'Hello World!'</span>;</span><br><span class="line"><span class="title function_">btoa</span>(string) <span class="comment">// "SGVsbG8gV29ybGQh"</span></span><br><span class="line"><span class="title function_">atob</span>(<span class="string">'SGVsbG8gV29ybGQh'</span>) <span class="comment">// "Hello World!"</span></span><br></pre></td></tr></tbody></table></figure><p>注意，这两个方法不适合非 ASCII 码的字符，会报错。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">btoa</span>(<span class="string">'你好'</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></tbody></table></figure><p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">b64Encode</span>(<span class="params">str</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">btoa</span>(<span class="built_in">encodeURIComponent</span>(str));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b64Decode</span>(<span class="params">str</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(<span class="title function_">atob</span>(str));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title function_">b64Encode</span>(<span class="string">'你好'</span>) <span class="comment">// "JUU0JUJEJUEwJUU1JUE1JUJE"</span></span><br><span class="line"><span class="title function_">b64Decode</span>(<span class="string">'JUU0JUJEJUEwJUU1JUE1JUJE'</span>) <span class="comment">// "你好"</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript数值&#39;</title>
      <link href="/2022/05/20/javascript-shu-zhi/"/>
      <url>/2022/05/20/javascript-shu-zhi/</url>
      
        <content type="html"><![CDATA[<h1>数值</h1><h2 id="概述-2">概述</h2><h3 id="整数和浮点数">整数和浮点数</h3><p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，<code>1</code>与<code>1.0</code>是相同的，是同一个数。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1.0</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算，参见《运算符》一章的“位运算”部分。</p><p>由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.3</span> / <span class="number">0.1</span></span><br><span class="line"><span class="comment">// 2.9999999999999996</span></span><br><span class="line"></span><br><span class="line">(<span class="number">0.3</span> - <span class="number">0.2</span>) === (<span class="number">0.2</span> - <span class="number">0.1</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><h3 id="数值精度">数值精度</h3><p>根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。</p><ul><li>第1位：符号位，<code>0</code>表示正数，<code>1</code>表示负数</li><li>第2位到第12位（共11位）：指数部分</li><li>第13位到第64位（共52位）：小数部分（即有效数字）</li></ul><p>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。</p><p>指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是<code>1.xx...xx</code>的形式，其中<code>xx..xx</code>的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-1)^符号位 * 1.xx...xx * 2^指数部分</span><br></pre></td></tr></tbody></table></figure><p>上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。</p><p>精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-2<sup>53</sup>到2<sup>53</sup>，都可以精确表示。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>)</span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">2</span></span><br><span class="line"><span class="comment">// 9007199254740994</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">3</span></span><br><span class="line"><span class="comment">// 9007199254740996</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">4</span></span><br><span class="line"><span class="comment">// 9007199254740996</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">53</span>)</span><br><span class="line"><span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多出的三个有效数字，将无法保存</span></span><br><span class="line"><span class="number">9007199254740992111</span></span><br><span class="line"><span class="comment">// 9007199254740992000</span></span><br></pre></td></tr></tbody></table></figure><p>上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的<code>111</code>）都会无法保存，变成0。</p><h3 id="数值范围">数值范围</h3><p>根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为2<sup>1024</sup>到2<sup>-1023</sup>（开区间），超出这个范围的数无法表示。</p><p>如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回<code>Infinity</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">1024</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></tbody></table></figure><p>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, -<span class="number">1075</span>) <span class="comment">// 0</span></span><br></pre></td></tr></tbody></table></figure><p>下面是一个实际的例子。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) {</span><br><span class="line">  x = x * x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">x <span class="comment">// 0</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，对<code>0.5</code>连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript 就直接将其转为0。</p><p>JavaScript 提供<code>Number</code>对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>属性，返回可以表示的具体的最大值和最小值。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_VALUE</span> <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_VALUE</span> <span class="comment">// 5e-324</span></span><br></pre></td></tr></tbody></table></figure><h2 id="数值的表示法">数值的表示法</h2><p>JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如<code>35</code>（十进制）和<code>0xFF</code>（十六进制）。</p><p>数值也可以采用科学计数法表示，下面是几个科学计数法的例子。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123e3</span> <span class="comment">// 123000</span></span><br><span class="line"><span class="number">123e-3</span> <span class="comment">// 0.123</span></span><br><span class="line">-<span class="number">3.1E+12</span></span><br><span class="line"><span class="number">.1e-23</span></span><br></pre></td></tr></tbody></table></figure><p>科学计数法允许字母<code>e</code>或<code>E</code>的后面，跟着一个整数，表示这个数值的指数部分。</p><p>以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。</p><p><strong>（1）小数点前的数字多于21位。</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1234567890123456789012</span></span><br><span class="line"><span class="comment">// 1.2345678901234568e+21</span></span><br><span class="line"></span><br><span class="line"><span class="number">123456789012345678901</span></span><br><span class="line"><span class="comment">// 123456789012345680000</span></span><br></pre></td></tr></tbody></table></figure><p><strong>（2）小数点后的零多于5个。</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小数点后紧跟5个以上的零，</span></span><br><span class="line"><span class="comment">// 就自动转为科学计数法</span></span><br><span class="line"><span class="number">0.0000003</span> <span class="comment">// 3e-7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 否则，就保持原来的字面形式</span></span><br><span class="line"><span class="number">0.000003</span> <span class="comment">// 0.000003</span></span><br></pre></td></tr></tbody></table></figure><h2 id="数值的进制">数值的进制</h2><p>使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。</p><ul><li>十进制：没有前导0的数值。</li><li>八进制：有前缀<code>0o</code>或<code>0O</code>的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。</li><li>十六进制：有前缀<code>0x</code>或<code>0X</code>的数值。</li><li>二进制：有前缀<code>0b</code>或<code>0B</code>的数值。</li></ul><p>默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xff</span> <span class="comment">// 255</span></span><br><span class="line"><span class="number">0o377</span> <span class="comment">// 255</span></span><br><span class="line"><span class="number">0b11</span> <span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure><p>如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xzz <span class="comment">// 报错</span></span><br><span class="line">0o88 <span class="comment">// 报错</span></span><br><span class="line">0b22 <span class="comment">// 报错</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，十六进制出现了字母<code>z</code>、八进制出现数字<code>8</code>、二进制出现数字<code>2</code>，因此报错。</p><p>通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字<code>8</code>和<code>9</code>，则该数值被视为十进制。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0888</span> <span class="comment">// 888</span></span><br><span class="line"><span class="number">0777</span> <span class="comment">// 511</span></span><br></pre></td></tr></tbody></table></figure><p>前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。</p><h2 id="特殊数值">特殊数值</h2><p>JavaScript 提供了几个特殊的数值。</p><h3 id="正零和负零">正零和负零</h3><p>前面说过，JavaScript 的64位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的负值，就连<code>0</code>也不例外。</p><p>JavaScript 内部实际上存在2个<code>0</code>：一个是<code>+0</code>，一个是<code>-0</code>，区别就是64位浮点数表示法的符号位不同。它们是等价的。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">0</span> === +<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === -<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> === +<span class="number">0</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>几乎所有场合，正零和负零都会被当作正常的<code>0</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> <span class="comment">// 0</span></span><br><span class="line">-<span class="number">0</span> <span class="comment">// 0</span></span><br><span class="line">(-<span class="number">0</span>).<span class="title function_">toString</span>() <span class="comment">// '0'</span></span><br><span class="line">(+<span class="number">0</span>).<span class="title function_">toString</span>() <span class="comment">// '0'</span></span><br></pre></td></tr></tbody></table></figure><p>唯一有区别的场合是，<code>+0</code>或<code>-0</code>当作分母，返回的值是不相等的。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> / +<span class="number">0</span>) === (<span class="number">1</span> / -<span class="number">0</span>) <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p>上面的代码之所以出现这样结果，是因为除以正零得到<code>+Infinity</code>，除以负零得到<code>-Infinity</code>，这两者是不相等的（关于<code>Infinity</code>详见下文）。</p><h3 id="NaN">NaN</h3><p><strong>（1）含义</strong></p><p><code>NaN</code>是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> - <span class="string">'x'</span> <span class="comment">// NaN</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码运行时，会自动将字符串<code>x</code>转为数值，但是由于<code>x</code>不是数值，所以最后得到结果为<code>NaN</code>，表示它是“非数字”（<code>NaN</code>）。</p><p>另外，一些数学函数的运算结果会出现<code>NaN</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">acos</span>(<span class="number">2</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">log</span>(-<span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">sqrt</span>(-<span class="number">1</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></tbody></table></figure><p><code>0</code>除以<code>0</code>也会得到<code>NaN</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> / <span class="number">0</span> <span class="comment">// NaN</span></span><br></pre></td></tr></tbody></table></figure><p>需要注意的是，<code>NaN</code>不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于<code>Number</code>，使用<code>typeof</code>运算符可以看得很清楚。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="title class_">NaN</span> <span class="comment">// 'number'</span></span><br></pre></td></tr></tbody></table></figure><p><strong>（2）运算规则</strong></p><p><code>NaN</code>不等于任何值，包括它本身。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p>数组的<code>indexOf</code>方法内部使用的是严格相等运算符，所以该方法对<code>NaN</code>不成立。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="title class_">NaN</span>].<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>) <span class="comment">// -1</span></span><br></pre></td></tr></tbody></table></figure><p><code>NaN</code>在布尔运算时被当作<code>false</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(<span class="title class_">NaN</span>) <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p><code>NaN</code>与任何数（包括它自己）的运算，得到的都是<code>NaN</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NaN</span> + <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">NaN</span> - <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">NaN</span> * <span class="number">32</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">NaN</span> / <span class="number">32</span> <span class="comment">// NaN</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Infinity">Infinity</h3><p><strong>（1）含义</strong></p><p><code>Infinity</code>表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到<code>Infinity</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景一</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景二</span></span><br><span class="line"><span class="number">0</span> / <span class="number">0</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="number">1</span> / <span class="number">0</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回<code>Infinity</code>。第二个场景是<code>0</code>除以<code>0</code>会得到<code>NaN</code>，而非0数值除以<code>0</code>，会返回<code>Infinity</code>。</p><p><code>Infinity</code>有正负之分，<code>Infinity</code>表示正的无穷，<code>-Infinity</code>表示负的无穷。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Infinity</span> === -<span class="title class_">Infinity</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> / -<span class="number">0</span> <span class="comment">// -Infinity</span></span><br><span class="line">-<span class="number">1</span> / -<span class="number">0</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，非零正数除以<code>-0</code>，会得到<code>-Infinity</code>，负数除以<code>-0</code>，会得到<code>Infinity</code>。</p><p>由于数值正向溢出（overflow）、负向溢出（underflow）和被<code>0</code>除，JavaScript 都不报错，所以单纯的数学运算几乎没有可能抛出错误。</p><p><code>Infinity</code>大于一切数值（除了<code>NaN</code>），<code>-Infinity</code>小于一切数值（除了<code>NaN</code>）。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Infinity</span> &gt; <span class="number">1000</span> <span class="comment">// true</span></span><br><span class="line">-<span class="title class_">Infinity</span> &lt; -<span class="number">1000</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p><code>Infinity</code>与<code>NaN</code>比较，总是返回<code>false</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Infinity</span> &gt; <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line">-<span class="title class_">Infinity</span> &gt; <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Infinity</span> &lt; <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line">-<span class="title class_">Infinity</span> &lt; <span class="title class_">NaN</span> <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p><strong>（2）运算规则</strong></p><p><code>Infinity</code>的四则运算，符合无穷的数学计算规则。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> * <span class="title class_">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> - <span class="title class_">Infinity</span> <span class="comment">// -Infinity</span></span><br><span class="line"><span class="title class_">Infinity</span> / <span class="number">5</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">5</span> / <span class="title class_">Infinity</span> <span class="comment">// 0</span></span><br></pre></td></tr></tbody></table></figure><p>0乘以<code>Infinity</code>，返回<code>NaN</code>；0除以<code>Infinity</code>，返回<code>0</code>；<code>Infinity</code>除以0，返回<code>Infinity</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> * <span class="title class_">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="number">0</span> / <span class="title class_">Infinity</span> <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Infinity</span> / <span class="number">0</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></tbody></table></figure><p><code>Infinity</code>加上或乘以<code>Infinity</code>，返回的还是<code>Infinity</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Infinity</span> + <span class="title class_">Infinity</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="title class_">Infinity</span> * <span class="title class_">Infinity</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></tbody></table></figure><p><code>Infinity</code>减去或除以<code>Infinity</code>，得到<code>NaN</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Infinity</span> - <span class="title class_">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Infinity</span> / <span class="title class_">Infinity</span> <span class="comment">// NaN</span></span><br></pre></td></tr></tbody></table></figure><p><code>Infinity</code>与<code>null</code>计算时，<code>null</code>会转成0，等同于与<code>0</code>的计算。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> * <span class="title class_">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">null</span> / <span class="title class_">Infinity</span> <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Infinity</span> / <span class="literal">null</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></tbody></table></figure><p><code>Infinity</code>与<code>undefined</code>计算，返回的都是<code>NaN</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> + <span class="title class_">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> - <span class="title class_">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> * <span class="title class_">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="literal">undefined</span> / <span class="title class_">Infinity</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Infinity</span> / <span class="literal">undefined</span> <span class="comment">// NaN</span></span><br></pre></td></tr></tbody></table></figure><h2 id="与数值相关的全局方法">与数值相关的全局方法</h2><h3 id="parseInt">parseInt()</h3><p><strong>（1）基本用法</strong></p><p><code>parseInt</code>方法用于将字符串转为整数。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>) <span class="comment">// 123</span></span><br></pre></td></tr></tbody></table></figure><p>如果字符串头部有空格，空格会被自动去除。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'   81'</span>) <span class="comment">// 81</span></span><br></pre></td></tr></tbody></table></figure><p>如果<code>parseInt</code>的参数不是字符串，则会先转为字符串再转换。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">1.23</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1.23'</span>) <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><p>字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'8a'</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12**'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12.34'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'15e2'</span>) <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'15px'</span>) <span class="comment">// 15</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，<code>parseInt</code>的参数都是字符串，结果只返回字符串头部可以转为数字的部分。</p><p>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回<code>NaN</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'abc'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'.3'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">''</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'+'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'+1'</span>) <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><p>所以，<code>parseInt</code>的返回值只有两种可能，要么是一个十进制整数，要么是<code>NaN</code>。</p><p>如果字符串以<code>0x</code>或<code>0X</code>开头，<code>parseInt</code>会将其按照十六进制数解析。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0x10'</span>) <span class="comment">// 16</span></span><br></pre></td></tr></tbody></table></figure><p>如果字符串以<code>0</code>开头，将其按照10进制解析。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'011'</span>) <span class="comment">// 11</span></span><br></pre></td></tr></tbody></table></figure><p>对于那些会自动转为科学计数法的数字，<code>parseInt</code>会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">1000000000000000000000.5</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1e+21'</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0.0000008</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'8e-7'</span>) <span class="comment">// 8</span></span><br></pre></td></tr></tbody></table></figure><p><strong>（2）进制转换</strong></p><p><code>parseInt</code>方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，<code>parseInt</code>的第二个参数为10，即默认是十进制转十进制。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>) <span class="comment">// 1000</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>, <span class="number">10</span>) <span class="comment">// 1000</span></span><br></pre></td></tr></tbody></table></figure><p>下面是转换指定进制的数的例子。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>, <span class="number">2</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>, <span class="number">6</span>) <span class="comment">// 216</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1000'</span>, <span class="number">8</span>) <span class="comment">// 512</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，二进制、六进制、八进制的<code>1000</code>，分别等于十进制的8、216和512。这意味着，可以用<code>parseInt</code>方法进行进制的转换。</p><p>如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回<code>NaN</code>。如果第二个参数是<code>0</code>、<code>undefined</code>和<code>null</code>，则直接忽略。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="number">37</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="number">0</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="literal">null</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>, <span class="literal">undefined</span>) <span class="comment">// 10</span></span><br></pre></td></tr></tbody></table></figure><p>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回<code>NaN</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1546'</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'546'</span>, <span class="number">2</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，对于二进制来说，<code>1</code>是有意义的字符，<code>5</code>、<code>4</code>、<code>6</code>都是无意义的字符，所以第一行返回1，第二行返回<code>NaN</code>。</p><p>前面说过，如果<code>parseInt</code>的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x11</span>, <span class="number">36</span>) <span class="comment">// 43</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x11</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="title class_">String</span>(<span class="number">0x11</span>), <span class="number">36</span>)</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="title class_">String</span>(<span class="number">0x11</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'17'</span>, <span class="number">36</span>)</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'17'</span>, <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，十六进制的<code>0x11</code>会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串<code>17</code>，最后返回结果<code>43</code>和<code>1</code>。</p><p>这种处理方式，对于八进制的前缀0，尤其需要注意。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">011</span>, <span class="number">2</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="title class_">String</span>(<span class="number">011</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="title class_">String</span>(<span class="number">9</span>), <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，第一行的<code>011</code>会被先转为字符串<code>9</code>，因为<code>9</code>不是二进制的有效字符，所以返回<code>NaN</code>。如果直接计算<code>parseInt('011', 2)</code>，<code>011</code>则是会被当作二进制处理，返回3。</p><p>JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个<code>0</code>。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。</p><h3 id="parseFloat">parseFloat()</h3><p><code>parseFloat</code>方法用于将一个字符串转为浮点数。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'3.14'</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></tbody></table></figure><p>如果字符串符合科学计数法，则会进行相应的转换。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'314e-2'</span>) <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'0.0314E+2'</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></tbody></table></figure><p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'3.14more non-digit characters'</span>) <span class="comment">// 3.14</span></span><br></pre></td></tr></tbody></table></figure><p><code>parseFloat</code>方法会自动过滤字符串前导的空格。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'\t\v\r12.34\n '</span>) <span class="comment">// 12.34</span></span><br></pre></td></tr></tbody></table></figure><p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回<code>NaN</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>([]) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'FF2'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">''</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，尤其值得注意，<code>parseFloat</code>会将空字符串转为<code>NaN</code>。</p><p>这些特点使得<code>parseFloat</code>的转换结果不同于<code>Number</code>函数。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">true</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">null</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">''</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">''</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'123.45#'</span>) <span class="comment">// 123.45</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">'123.45#'</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></tbody></table></figure><h3 id="isNaN">isNaN()</h3><p><code>isNaN</code>方法可以用来判断一个值是否为<code>NaN</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">123</span>) <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p>但是，<code>isNaN</code>只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成<code>NaN</code>，所以最后返回<code>true</code>，这一点要特别引起注意。也就是说，<code>isNaN</code>为<code>true</code>的值，有可能不是<code>NaN</code>，而是一个字符串。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="string">'Hello'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">Number</span>(<span class="string">'Hello'</span>)) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>出于同样的原因，对于对象和数组，<code>isNaN</code>也返回<code>true</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>({}) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">Number</span>({})) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">'xzy'</span>]) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">Number</span>([<span class="string">'xzy'</span>])) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>但是，对于空数组和只有一个数值成员的数组，<code>isNaN</code>返回<code>false</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>([]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="number">123</span>]) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>([<span class="string">'123'</span>]) <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码之所以返回<code>false</code>，原因是这些数组能被<code>Number</code>函数转成数值，请参见《数据类型转换》一章。</p><p>因此，使用<code>isNaN</code>之前，最好判断一下数据类型。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myIsNaN</span>(<span class="params">value</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'number'</span> &amp;&amp; <span class="built_in">isNaN</span>(value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>判断<code>NaN</code>更可靠的方法是，利用<code>NaN</code>为唯一不等于自身的值的这个特点，进行判断。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myIsNaN</span>(<span class="params">value</span>) {</span><br><span class="line">  <span class="keyword">return</span> value !== value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="isFinite">isFinite()</h3><p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="title class_">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="title class_">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="title class_">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="literal">null</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="number">1</span>) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 数据类型 </tag>
            
            <tag> 数值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的null、undefind和布尔值&#39;</title>
      <link href="/2022/05/20/javascript-de-null-undefind-he-bu-er-zhi/"/>
      <url>/2022/05/20/javascript-de-null-undefind-he-bu-er-zhi/</url>
      
        <content type="html"><![CDATA[<h1>null, undefined 和布尔值</h1><h2 id="null-和-undefined">null 和 undefined</h2><h3 id="概述-3">概述</h3><p><code>null</code>与<code>undefined</code>都可以表示“没有”，含义非常相似。将一个变量赋值为<code>undefined</code>或<code>null</code>，老实说，语法效果几乎没区别。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，变量<code>a</code>分别被赋值为<code>undefined</code>和<code>null</code>，这两种写法的效果几乎等价。</p><p>在<code>if</code>语句中，它们都会被自动转为<code>false</code>，相等运算符（<code>==</code>）甚至直接报告两者相等。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="literal">undefined</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'undefined is false'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// undefined is false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">null</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'null is false'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// null is false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>从上面代码可见，两者的行为是何等相似！谷歌公司开发的 JavaScript 语言的替代品 Dart 语言，就明确规定只有<code>null</code>，没有<code>undefined</code>！</p><p>既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。</p><p>1995年 JavaScript 诞生时，最初像 Java 一样，只设置了<code>null</code>表示"无"。根据 C 语言的传统，<code>null</code>可以自动转为<code>0</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="number">5</span> + <span class="literal">null</span> <span class="comment">// 5</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，<code>null</code>转为数字时，自动变成0。</p><p>但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，<code>null</code>就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果<code>null</code>自动转为0，很不容易发现错误。</p><p>因此，他又设计了一个<code>undefined</code>。区别是这样的：<code>null</code>是一个表示“空”的对象，转为数值时为<code>0</code>；<code>undefined</code>是一个表示"此处无定义"的原始值，转为数值时为<code>NaN</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="number">5</span> + <span class="literal">undefined</span> <span class="comment">// NaN</span></span><br></pre></td></tr></tbody></table></figure><h3 id="用法和含义">用法和含义</h3><p>对于<code>null</code>和<code>undefined</code>，大致可以像下面这样理解。</p><p><code>null</code>表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入<code>null</code>，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入<code>null</code>，表示未发生错误。</p><p><code>undefined</code>表示“未定义”，下面是返回<code>undefined</code>的典型场景。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量声明了，但没有赋值</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">i <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) {</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">}</span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象没有赋值的属性</span></span><br><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">o.<span class="property">p</span> <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数没有返回值时，默认返回 undefined</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) {}</span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></tbody></table></figure><h2 id="布尔值">布尔值</h2><p>布尔值代表“真”和“假”两个状态。“真”用关键字<code>true</code>表示，“假”用关键字<code>false</code>表示。布尔值只有这两个值。</p><p>下列运算符会返回布尔值：</p><ul><li>前置逻辑运算符： <code>!</code> (Not)</li><li>相等运算符：<code>===</code>，<code>!==</code>，<code>==</code>，<code>!=</code></li><li>比较运算符：<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code></li></ul><p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为<code>false</code>，其他值都视为<code>true</code>。</p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>false</code></li><li><code>0</code></li><li><code>NaN</code></li><li><code>""</code>或<code>''</code>（空字符串）</li></ul><p>布尔值往往用于程序流程的控制，请看一个例子。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">''</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'true'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 没有任何输出</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，<code>if</code>命令后面的判断条件，预期应该是一个布尔值，所以 JavaScript 自动将空字符串，转为布尔值<code>false</code>，导致程序不会进入代码块，所以没有任何输出。</p><p>注意，空数组（<code>[]</code>）和空对象（<code>{}</code>）对应的布尔值，都是<code>true</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([]) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'true'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ({}) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'true'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 数据类型 </tag>
            
            <tag> undefined </tag>
            
            <tag> 布尔值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript数据类型概述&#39;</title>
      <link href="/2022/05/20/javascript-shu-ju-lei-xing-gai-shu/"/>
      <url>/2022/05/20/javascript-shu-ju-lei-xing-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1>数据类型概述</h1><h2 id="简介">简介</h2><p>JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，本教程不涉及。）</p><ul><li>数值（number）：整数和小数（比如<code>1</code>和<code>3.14</code>）。</li><li>字符串（string）：文本（比如<code>Hello World</code>）。</li><li>布尔值（boolean）：表示真伪的两个特殊值，即<code>true</code>（真）和<code>false</code>（假）。</li><li><code>undefined</code>：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。</li><li><code>null</code>：表示空值，即此处的值为空。</li><li>对象（object）：各种值组成的集合。</li></ul><p>通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于<code>undefined</code>和<code>null</code>，一般将它们看成两个特殊值。</p><p>对象是最复杂的数据类型，又可以分成三个子类型。</p><ul><li>狭义的对象（object）</li><li>数组（array）</li><li>函数（function）</li></ul><p>狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的“对象”都特指狭义的对象。函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。</p><h2 id="typeof-运算符">typeof 运算符</h2><p>JavaScript 有三种方法，可以确定一个值到底是什么类型。</p><ul><li><code>typeof</code>运算符</li><li><code>instanceof</code>运算符</li><li><code>Object.prototype.toString</code>方法</li></ul><p><code>instanceof</code>运算符和<code>Object.prototype.toString</code>方法，将在后文介绍。这里介绍<code>typeof</code>运算符。</p><p><code>typeof</code>运算符可以返回一个值的数据类型。</p><p>数值、字符串、布尔值分别返回<code>number</code>、<code>string</code>、<code>boolean</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'123'</span> <span class="comment">// "string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span> <span class="comment">// "boolean"</span></span><br></pre></td></tr></tbody></table></figure><p>函数返回<code>function</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) {}</span><br><span class="line"><span class="keyword">typeof</span> f</span><br><span class="line"><span class="comment">// "function"</span></span><br></pre></td></tr></tbody></table></figure><p><code>undefined</code>返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// "undefined"</span></span><br></pre></td></tr></tbody></table></figure><p>利用这一点，<code>typeof</code>可以用来检查一个没有声明的变量，而不报错。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v</span><br><span class="line"><span class="comment">// ReferenceError: v is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> v</span><br><span class="line"><span class="comment">// "undefined"</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，变量<code>v</code>没有用<code>var</code>命令声明，直接使用就会报错。但是，放在<code>typeof</code>后面，就不报错了，而是返回<code>undefined</code>。</p><p>实际编程中，这个特点通常用在判断语句。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">if</span> (v) {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// ReferenceError: v is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> v === <span class="string">"undefined"</span>) {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对象返回<code>object</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="variable language_">window</span> <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> {} <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// "object"</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，空数组（<code>[]</code>）的类型也是<code>object</code>，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，<code>instanceof</code>运算符可以区分数组和对象。<code>instanceof</code>运算符的详细解释，请见《面向对象编程》一章。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = {};</span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line">o <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// false</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p><code>null</code>返回<code>object</code>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// "object"</span></span><br></pre></td></tr></tbody></table></figure><p><code>null</code>的类型是<code>object</code>，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑<code>null</code>，只把它当作<code>object</code>的一种特殊值。后来<code>null</code>独立出来，作为一种单独的数据类型，为了兼容以前的代码，<code>typeof null</code>返回<code>object</code>就没法改变了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JavaScript数据类型 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基本语法&#39;</title>
      <link href="/2022/05/20/javascript-ji-ben-yu-fa/"/>
      <url>/2022/05/20/javascript-ji-ben-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1>JavaScript 的基本语法</h1><h2 id="语句">语句</h2><p>JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。</p><p>语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">3</span>;</span><br></pre></td></tr></tbody></table></figure><p>这条语句先用<code>var</code>命令，声明了变量<code>a</code>，然后将<code>1 + 3</code>的运算结果赋值给变量<code>a</code>。</p><p><code>1 + 3</code>叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。</p><p>语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">3</span> ; <span class="keyword">var</span> b = <span class="string">'abc'</span>;</span><br></pre></td></tr></tbody></table></figure><p>分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;;;</span><br></pre></td></tr></tbody></table></figure><p>上面的代码就表示3个空语句。</p><p>表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">3</span>;</span><br><span class="line"><span class="string">'abc'</span>;</span><br></pre></td></tr></tbody></table></figure><p>上面两行语句只是单纯地产生一个值，并没有任何实际的意义。</p><h2 id="变量">变量</h2><h3 id="概念">概念</h3><p>变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>上面的代码先声明变量<code>a</code>，然后在变量<code>a</code>与数值1之间建立引用关系，称为将数值1“赋值”给变量<code>a</code>。以后，引用变量名<code>a</code>就会得到数值1。最前面的<code>var</code>，是变量声明命令。它表示通知解释引擎，要创建一个变量<code>a</code>。</p><p>注意，JavaScript 的变量名区分大小写，<code>A</code>和<code>a</code>是两个不同的变量。</p><p>变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>如果只是声明变量而没有赋值，则该变量的值是<code>undefined</code>。<code>undefined</code>是一个特殊的值，表示“无定义”。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a <span class="comment">// undefined</span></span><br></pre></td></tr></tbody></table></figure><p>如果变量赋值的时候，忘了写<code>var</code>命令，这条语句也是有效的。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 基本等同</span></span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>但是，不写<code>var</code>的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用<code>var</code>命令声明变量。</p><p>如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x</span><br><span class="line"><span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码直接使用变量<code>x</code>，系统就报错，告诉你变量<code>x</code>没有声明。</p><p>可以在同一条<code>var</code>命令中声明多个变量。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br></pre></td></tr></tbody></table></figure><p>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="string">'hello'</span>;</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，变量<code>a</code>起先被赋值为一个数值，后来又被重新赋值为一个字符串。第二次赋值的时候，因为变量<code>a</code>已经存在，所以不需要使用<code>var</code>命令。</p><p>如果使用<code>var</code>重新声明一个已经存在的变量，是无效的。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，变量<code>x</code>声明了两次，第二次声明是无效的。</p><p>但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x = <span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="变量提升">变量提升</h3><p>JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>上面代码首先使用<code>console.log</code>方法，在控制台（console）显示变量<code>a</code>的值。这时变量<code>a</code>还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>最后的结果是显示<code>undefined</code>，表示变量<code>a</code>已声明，但还未赋值。</p><h2 id="标识符">标识符</h2><p>标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以<code>a</code>和<code>A</code>是两个不同的标识符。</p><p>标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。</p><p>简单说，标识符命名规则如下。</p><ul><li>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（<code>$</code>）和下划线（<code>_</code>）。</li><li>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字<code>0-9</code>。</li></ul><p>下面这些都是合法的标识符。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arg0</span><br><span class="line">_tmp</span><br><span class="line">$elem</span><br><span class="line">π</span><br></pre></td></tr></tbody></table></figure><p>下面这些则是不合法的标识符。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1a  <span class="comment">// 第一个字符不能是数字</span></span><br><span class="line"><span class="number">23</span>  <span class="comment">// 同上</span></span><br><span class="line">***  <span class="comment">// 标识符不能包含星号</span></span><br><span class="line">a+b  <span class="comment">// 标识符不能包含加号</span></span><br><span class="line">-d  <span class="comment">// 标识符不能包含减号或连词线</span></span><br></pre></td></tr></tbody></table></figure><p>中文是合法的标识符，可以用作变量名。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 临时变量 = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</p></blockquote><h2 id="注释">注释</h2><p>源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。JavaScript 提供两种注释的写法：一种是单行注释，用<code>//</code>起头；另一种是多行注释，放在<code>/*</code>和<code>*/</code>之间。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 这是</span></span><br><span class="line"><span class="comment"> 多行</span></span><br><span class="line"><span class="comment"> 注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以<code>&lt;!--</code>和<code>--&gt;</code>也被视为合法的单行注释。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>; &lt;!-- x = <span class="number">2</span>;</span><br><span class="line">--&gt; x = <span class="number">3</span>;</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，只有<code>x = 1</code>会执行，其他的部分都被注释掉了。</p><p>需要注意的是，<code>--&gt;</code>只有在行首，才会被当成单行注释，否则会当作正常的运算。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countdown</span>(<span class="params">n</span>) {</span><br><span class="line">  <span class="keyword">while</span> (n --&gt; <span class="number">0</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">}</span><br><span class="line"><span class="title function_">countdown</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，<code>n --&gt; 0</code>实际上会当作<code>n-- &gt; 0</code>，因此输出2、1、0。</p><h2 id="区块">区块</h2><p>JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。</p><p>对于<code>var</code>命令来说，JavaScript 的区块不构成单独的作用域（scope）。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">a <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码在区块内部，使用<code>var</code>命令声明并赋值了变量<code>a</code>，然后在区块外部，变量<code>a</code>依然有效，区块对于<code>var</code>命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 JavaScript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如<code>for</code>、<code>if</code>、<code>while</code>、<code>function</code>等。</p><h2 id="条件语句">条件语句</h2><p>JavaScript 提供<code>if</code>结构和<code>switch</code>结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。</p><h3 id="if-结构">if 结构</h3><p><code>if</code>结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，<code>true</code>表示“真”，<code>false</code>表示“伪”。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔值)</span><br><span class="line">  语句;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span> (布尔值) 语句;</span><br></pre></td></tr></tbody></table></figure><p>上面是<code>if</code>结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为<code>true</code>，就执行紧跟在后面的语句；如果结果为<code>false</code>，则跳过紧跟在后面的语句。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m === <span class="number">3</span>)</span><br><span class="line">  m = m + <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>上面代码表示，只有在<code>m</code>等于3时，才会将其值加上1。</p><p>这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在<code>if</code>的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m === <span class="number">3</span>) {</span><br><span class="line">  m += <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>建议总是在<code>if</code>语句中使用大括号，因为这样方便插入语句。</p><p>注意，<code>if</code>后面的表达式之中，不要混淆赋值表达式（<code>=</code>）、严格相等运算符（<code>===</code>）和相等运算符（<code>==</code>）。尤其是赋值表达式不具有比较作用。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (x = y) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// "2"</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码的原意是，当<code>x</code>等于<code>y</code>的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将<code>y</code>赋值给变量<code>x</code>，再判断变量<code>x</code>的值（等于2）的布尔值（结果为<code>true</code>）。</p><p>这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x = <span class="number">2</span>) { <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> = x) { <span class="comment">// 报错</span></span><br></pre></td></tr></tbody></table></figure><p>至于为什么优先采用“严格相等运算符”（<code>===</code>），而不是“相等运算符”（<code>==</code>），请参考《运算符》章节。</p><h3 id="if…else-结构">if…else 结构</h3><p><code>if</code>代码块后面，还可以跟一个<code>else</code>代码块，表示不满足条件时，所要执行的代码。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m === <span class="number">3</span>) {</span><br><span class="line">  <span class="comment">// 满足条件时，执行的语句</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">// 不满足条件时，执行的语句</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码判断变量<code>m</code>是否等于3，如果等于就执行<code>if</code>代码块，否则执行<code>else</code>代码块。</p><p>对同一个变量进行多次判断时，多个<code>if...else</code>语句可以连写在一起。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m === <span class="number">0</span>) {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (m === <span class="number">1</span>) {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (m === <span class="number">2</span>) {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>else</code>代码块总是与离自己最近的那个<code>if</code>语句配对。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m !== <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> (n === <span class="number">2</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'world'</span>);</span><br></pre></td></tr></tbody></table></figure><p>上面代码不会有任何输出，<code>else</code>代码块不会得到执行，因为它跟着的是最近的那个<code>if</code>语句，相当于下面这样。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m !== <span class="number">1</span>) {</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'hello'</span>);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'world'</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果想让<code>else</code>代码块跟随最上面的那个<code>if</code>语句，就要改变大括号的位置。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m !== <span class="number">1</span>) {</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">2</span>) {</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'hello'</span>);</span><br><span class="line">  }</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'world'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></tbody></table></figure><h3 id="switch-结构">switch 结构</h3><p>多个<code>if...else</code>连在一起使用的时候，可以转为使用更方便的<code>switch</code>结构。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (fruit) {</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"banana"</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"apple"</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码根据变量<code>fruit</code>的值，选择执行相应的<code>case</code>。如果所有<code>case</code>都不符合，则执行最后的<code>default</code>部分。需要注意的是，每个<code>case</code>代码块内部的<code>break</code>语句不能少，否则会接下去执行下一个<code>case</code>代码块，而不是跳出<code>switch</code>结构。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (x) {</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'x 等于1'</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'x 等于2'</span>);</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'x 等于其他值'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// x等于1</span></span><br><span class="line"><span class="comment">// x等于2</span></span><br><span class="line"><span class="comment">// x等于其他值</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，<code>case</code>代码块之中没有<code>break</code>语句，导致不会跳出<code>switch</code>结构，而会一直执行下去。正确的写法是像下面这样。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (x) {</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'x 等于1'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'x 等于2'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'x 等于其他值'</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>switch</code>语句部分和<code>case</code>语句部分，都可以使用表达式。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">1</span> + <span class="number">3</span>) {</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> + <span class="number">2</span>:</span><br><span class="line">    <span class="title function_">f</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="title function_">neverHappens</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码的<code>default</code>部分，是永远不会执行到的。</p><p>需要注意的是，<code>switch</code>语句后面的表达式，与<code>case</code>语句后面的表示式比较运行结果时，采用的是严格相等运算符（<code>===</code>），而不是相等运算符（<code>==</code>），这意味着比较时不会发生类型转换。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (x) {</span><br><span class="line">  <span class="keyword">case</span> <span class="attr">true</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'x 发生类型转换'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'x 没有发生类型转换'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// x 没有发生类型转换</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，由于变量<code>x</code>没有发生类型转换，所以不会执行<code>case true</code>的情况。这表明，<code>switch</code>语句内部采用的是“严格相等运算符”，详细解释请参考《运算符》一节。</p><h3 id="三元运算符">三元运算符 ?:</h3><p>JavaScript 还有一个三元运算符（即该运算符需要三个运算子）<code>?:</code>，也可以用于逻辑判断。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(条件) ? 表达式<span class="number">1</span> : 表达式<span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，如果“条件”为<code>true</code>，则返回“表达式1”的值，否则返回“表达式2”的值。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> even = (n % <span class="number">2</span> === <span class="number">0</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，如果<code>n</code>可以被2整除，则<code>even</code>等于<code>true</code>，否则等于<code>false</code>。它等同于下面的形式。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> even;</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">0</span>) {</span><br><span class="line">  even = <span class="literal">true</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  even = <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个三元运算符可以被视为<code>if...else...</code>的简写形式，因此可以用于多种场合。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  myVar ?</span><br><span class="line">  <span class="string">'myVar has a value'</span> :</span><br><span class="line">  <span class="string">'myVar does not have a value'</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// myVar does not have a value</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码利用三元运算符，输出相应的提示。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">'数字'</span> + n + <span class="string">'是'</span> + (n % <span class="number">2</span> === <span class="number">0</span> ? <span class="string">'偶数'</span> : <span class="string">'奇数'</span>);</span><br></pre></td></tr></tbody></table></figure><p>上面代码利用三元运算符，在字符串之中插入不同的值。</p><h2 id="循环语句">循环语句</h2><p>循环语句用于重复执行某个操作，它有多种形式。</p><h3 id="while-循环">while 循环</h3><p><code>While</code>语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件)</span><br><span class="line">  语句;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">while</span> (条件) 语句;</span><br></pre></td></tr></tbody></table></figure><p><code>while</code>语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) {</span><br><span class="line">  语句;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面是<code>while</code>语句的一个例子。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">100</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'i 当前为：'</span> + i);</span><br><span class="line">  i = i + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的代码将循环100次，直到<code>i</code>等于100为止。</p><p>下面的例子是一个无限循环，因为循环条件总是为真。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Hello, world'</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="for-循环">for 循环</h3><p><code>for</code>语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化表达式; 条件; 递增表达式)</span><br><span class="line">  语句</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (初始化表达式; 条件; 递增表达式) {</span><br><span class="line">  语句</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>for</code>语句后面的括号里面，有三个表达式。</p><ul><li>初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。</li><li>条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。</li><li>递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。</li></ul><p>下面是一个例子。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; x; i++) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，初始化表达式是<code>var i = 0</code>，即初始化一个变量<code>i</code>；测试表达式是<code>i &lt; x</code>，即只要<code>i</code>小于<code>x</code>，就会执行循环；递增表达式是<code>i++</code>，即每次循环结束后，<code>i</code>增大1。</p><p>所有<code>for</code>循环，都可以改写成<code>while</code>循环。上面的例子改为<code>while</code>循环，代码如下。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; x) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  i++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>for</code>语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ; ; ){</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Hello World'</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码省略了<code>for</code>语句表达式的三个部分，结果就导致了一个无限循环。</p><h3 id="do…while-循环">do…while 循环</h3><p><code>do...while</code>循环与<code>while</code>循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  语句</span><br><span class="line"><span class="keyword">while</span> (条件);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">  语句</span><br><span class="line">} <span class="keyword">while</span> (条件);</span><br></pre></td></tr></tbody></table></figure><p>不管条件是否为真，<code>do...while</code>循环至少运行一次，这是这种结构最大的特点。另外，<code>while</code>语句后面的分号注意不要省略。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  i++;</span><br><span class="line">} <span class="keyword">while</span>(i &lt; x);</span><br></pre></td></tr></tbody></table></figure><h3 id="break-语句和-continue-语句">break 语句和 continue 语句</h3><p><code>break</code>语句和<code>continue</code>语句都具有跳转作用，可以让代码不按既有的顺序执行。</p><p><code>break</code>语句用于跳出代码块或循环。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">100</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'i 当前为：'</span> + i);</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">10</span>) <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码只会执行10次循环，一旦<code>i</code>等于10，就会跳出循环。</p><p><code>for</code>循环也可以使用<code>break</code>语句跳出循环。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码执行到<code>i</code>等于3，就会跳出循环。</p><p><code>continue</code>语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">100</span>){</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'i 当前为：'</span> + i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码只有在<code>i</code>为奇数时，才会输出<code>i</code>的值。如果<code>i</code>为偶数，则直接进入下一轮循环。</p><p>如果存在多重循环，不带参数的<code>break</code>语句和<code>continue</code>语句都只针对最内层循环。</p><h3 id="标签（label）">标签（label）</h3><p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">label</span>:</span><br><span class="line">  语句</span><br></pre></td></tr></tbody></table></figure><p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。</p><p>标签通常与<code>break</code>语句和<code>continue</code>语句配合使用，跳出特定的循环。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">top</span>:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++){</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++){</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">break</span> top;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'i='</span> + i + <span class="string">', j='</span> + j);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"><span class="comment">// i=0, j=0</span></span><br><span class="line"><span class="comment">// i=0, j=1</span></span><br><span class="line"><span class="comment">// i=0, j=2</span></span><br><span class="line"><span class="comment">// i=1, j=0</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码为一个双重循环区块，<code>break</code>命令后面加上了<code>top</code>标签（注意，<code>top</code>不用加引号），满足条件时，直接跳出双层循环。如果<code>break</code>语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。</p><p>标签也可以用于跳出代码块。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">foo</span>: {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">break</span> foo;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'本行不会输出'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码执行到<code>break foo</code>，就会跳出区块。</p><p><code>continue</code>语句也可以与标签配合使用。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">top</span>:</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++){</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++){</span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">continue</span> top;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'i='</span> + i + <span class="string">', j='</span> + j);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"><span class="comment">// i=0, j=0</span></span><br><span class="line"><span class="comment">// i=0, j=1</span></span><br><span class="line"><span class="comment">// i=0, j=2</span></span><br><span class="line"><span class="comment">// i=1, j=0</span></span><br><span class="line"><span class="comment">// i=2, j=0</span></span><br><span class="line"><span class="comment">// i=2, j=1</span></span><br><span class="line"><span class="comment">// i=2, j=2</span></span><br></pre></td></tr></tbody></table></figure><p>上面代码中，<code>continue</code>命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果<code>continue</code>语句后面不使用标签，则只能进入下一轮的内层循环。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> js </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript概述&#39;</title>
      <link href="/2022/05/20/javascript-gai-shu/"/>
      <url>/2022/05/20/javascript-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1>导论</h1><h2 id="什么是-JavaScript-语言？">什么是 JavaScript 语言？</h2><p>JavaScript 是一种轻量级的脚本语言。所谓“脚本语言”（script language），指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”。</p><p>JavaScript 也是一种嵌入式（embedded）语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。</p><p>目前，已经嵌入 JavaScript 的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 项目。</p><p>从语法角度看，JavaScript 语言是一种“对象模型”语言。各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过 JavaScript 控制这些功能。但是，JavaScript 并不是纯粹的“面向对象语言”，还支持其他编程范式（比如函数式编程）。这导致几乎任何一个问题，JavaScript 都有多种解决方法。阅读本书的过程中，你会诧异于 JavaScript 语法的灵活性。</p><p>JavaScript 的核心语法部分相当精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（就是一系列具有各种功能的对象比如<code>Array</code>、<code>Date</code>、<code>Math</code>等）。除此之外，各种宿主环境提供额外的 API（即只能在该环境使用的接口），以便 JavaScript 调用。以浏览器为例，它提供的额外 API 可以分成三大类。</p><ul><li>浏览器控制类：操作浏览器</li><li>DOM 类：操作网页的各种元素</li><li>Web 类：实现互联网的各种功能</li></ul><p>如果宿主环境是服务器，则会提供各种操作系统的 API，比如文件操作 API、网络通信 API等等。这些你都可以在 Node 环境中找到。</p><p>本书主要介绍 JavaScript 核心语法和浏览器网页开发的基本知识，不涉及 Node。全书可以分成以下四大部分。</p><ul><li>基本语法</li><li>标准库</li><li>浏览器 API</li><li>DOM</li></ul><p>JavaScript 语言有多个版本。本书的内容主要基于 ECMAScript 5.1 版本，这是学习 JavaScript 语法的基础。ES6 和更新的语法请参考我写的<a href="http://es6.ruanyifeng.com/">《ECMAScript 6入门》</a>。</p><h2 id="为什么学习-JavaScript？">为什么学习 JavaScript？</h2><p>JavaScript 语言有一些显著特点，使得它非常值得学习。它既适合作为学习编程的入门语言，也适合当作日常开发的工作语言。它是目前最有希望、前途最光明的计算机语言之一。</p><h3 id="操控浏览器的能力">操控浏览器的能力</h3><p>JavaScript 的发明目的，就是作为浏览器的内置脚本语言，为网页开发者提供操控浏览器的能力。它是目前唯一一种通用的浏览器脚本语言，所有浏览器都支持。它可以让网页呈现各种特殊效果，为用户提供良好的互动体验。</p><p>目前，全世界几乎所有网页都使用 JavaScript。如果不用，网站的易用性和使用效率将大打折扣，无法成为操作便利、对用户友好的网站。</p><p>对于一个互联网开发者来说，如果你想提供漂亮的网页、令用户满意的上网体验、各种基于浏览器的便捷功能、前后端之间紧密高效的联系，JavaScript 是必不可少的工具。</p><h3 id="广泛的使用领域">广泛的使用领域</h3><p>近年来，JavaScript 的使用范围，慢慢超越了浏览器，正在向通用的系统语言发展。</p><p><strong>（1）浏览器的平台化</strong></p><p>随着 HTML5 的出现，浏览器本身的功能越来越强，不再仅仅能浏览网页，而是越来越像一个平台，JavaScript 因此得以调用许多系统功能，比如操作本地文件、操作图片、调用摄像头和麦克风等等。这使得 JavaScript 可以完成许多以前无法想象的事情。</p><p><strong>（2）Node</strong></p><p>Node 项目使得 JavaScript 可以用于开发服务器端的大型项目，网站的前后端都用 JavaScript 开发已经成为了现实。有些嵌入式平台（Raspberry Pi）能够安装 Node，于是 JavaScript 就能为这些平台开发应用程序。</p><p><strong>（3）数据库操作</strong></p><p>JavaScript 甚至也可以用来操作数据库。NoSQL 数据库这个概念，本身就是在 JSON（JavaScript Object Notation）格式的基础上诞生的，大部分 NoSQL 数据库允许 JavaScript 直接操作。基于 SQL 语言的开源数据库 PostgreSQL 支持 JavaScript 作为操作语言，可以部分取代 SQL 查询语言。</p><p><strong>（4）移动平台开发</strong></p><p>JavaScript 也正在成为手机应用的开发语言。一般来说，安卓平台使用 Java 语言开发，iOS 平台使用 Objective-C 或 Swift 语言开发。许多人正在努力，让 JavaScript 成为各个平台的通用开发语言。</p><p>PhoneGap 项目就是将 JavaScript 和 HTML5 打包在一个容器之中，使得它能同时在 iOS 和安卓上运行。Facebook 公司的 React Native 项目则是将 JavaScript 写的组件，编译成原生组件，从而使它们具备优秀的性能。</p><p>Mozilla 基金会的手机操作系统 Firefox OS，更是直接将 JavaScript 作为操作系统的平台语言，但是很可惜这个项目没有成功。</p><p><strong>（5）内嵌脚本语言</strong></p><p>越来越多的应用程序，将 JavaScript 作为内嵌的脚本语言，比如 Adobe 公司的著名 PDF 阅读器 Acrobat、Linux 桌面环境 GNOME 3。</p><p><strong>（6）跨平台的桌面应用程序</strong></p><p>Chromium OS、Windows 8 等操作系统直接支持 JavaScript 编写应用程序。Mozilla 的 Open Web Apps 项目、Google 的 <a href="http://developer.chrome.com/apps/about_apps">Chrome App 项目</a>、GitHub 的 <a href="http://electron.atom.io/">Electron 项目</a>、以及 <a href="http://tidesdk.multipart.net/docs/user-dev/generated/">TideSDK 项目</a>，都可以用来编写运行于 Windows、Mac OS 和 Android 等多个桌面平台的程序，不依赖浏览器。</p><p><strong>（7）小结</strong></p><p>可以预期，JavaScript 最终将能让你只用一种语言，就开发出适应不同平台（包括桌面端、服务器端、手机端）的程序。早在2013年9月的<a href="http://adambard.com/blog/top-github-languages-for-2013-so-far/">统计</a>之中，JavaScript 就是当年 GitHub 上使用量排名第一的语言。</p><p>著名程序员 Jeff Atwood 甚至提出了一条 <a href="http://www.codinghorror.com/blog/2007/07/the-principle-of-least-power.html">“Atwood 定律”</a>：</p><blockquote><p>“所有可以用 JavaScript 编写的程序，最终都会出现 JavaScript 的版本。”(Any application that can be written in JavaScript will eventually be written in JavaScript.)</p></blockquote><h3 id="易学性">易学性</h3><p>相比学习其他语言，学习 JavaScript 有一些有利条件。</p><p><strong>（1）学习环境无处不在</strong></p><p>只要有浏览器，就能运行 JavaScript 程序；只要有文本编辑器，就能编写 JavaScript 程序。这意味着，几乎所有电脑都原生提供 JavaScript 学习环境，不用另行安装复杂的 IDE（集成开发环境）和编译器。</p><p><strong>（2）简单性</strong></p><p>相比其他脚本语言（比如 Python 或 Ruby），JavaScript 的语法相对简单一些，本身的语法特性并不是特别多。而且，那些语法中的复杂部分，也不是必需要学会。你完全可以只用简单命令，完成大部分的操作。</p><p><strong>（3）与主流语言的相似性</strong></p><p>JavaScript 的语法很类似 C/C++ 和 Java，如果学过这些语言（事实上大多数学校都教），JavaScript 的入门会非常容易。</p><p>必须说明的是，虽然核心语法不难，但是 JavaScript 的复杂性体现在另外两个方面。</p><p>首先，它涉及大量的外部 API。JavaScript 要发挥作用，必须与其他组件配合，这些外部组件五花八门，数量极其庞大，几乎涉及网络应用的各个方面，掌握它们绝非易事。</p><p>其次，JavaScript 语言有一些设计缺陷。某些地方相当不合理，另一些地方则会出现怪异的运行结果。学习 JavaScript，很大一部分时间是用来搞清楚哪些地方有陷阱。Douglas Crockford 写过一本有名的书，名字就叫<a href="http://javascript.crockford.com/">《JavaScript: The Good Parts》</a>，言下之意就是这门语言不好的地方很多，必须写一本书才能讲清楚。另外一些程序员则感到，为了更合理地编写 JavaScript 程序，就不能用 JavaScript 来写，而必须发明新的语言，比如 CoffeeScript、TypeScript、Dart 这些新语言的发明目的，多多少少都有这个因素。</p><p>尽管如此，目前看来，JavaScript 的地位还是无法动摇。加之，语言标准的快速进化，使得 JavaScript 功能日益增强，而语法缺陷和怪异之处得到了弥补。所以，JavaScript 还是值得学习，况且它的入门真的不难。</p><h3 id="强大的性能">强大的性能</h3><p>JavaScript 的性能优势体现在以下方面。</p><p><strong>（1）灵活的语法，表达力强。</strong></p><p>JavaScript 既支持类似 C 语言清晰的过程式编程，也支持灵活的函数式编程，可以用来写并发处理（concurrent）。这些语法特性已经被证明非常强大，可以用于许多场合，尤其适用异步编程。</p><p>JavaScript 的所有值都是对象，这为程序员提供了灵活性和便利性。因为你可以很方便地、按照需要随时创造数据结构，不用进行麻烦的预定义。</p><p>JavaScript 的标准还在快速进化中，并不断合理化，添加更适用的语法特性。</p><p><strong>（2）支持编译运行。</strong></p><p>JavaScript 语言本身，虽然是一种解释型语言，但是在现代浏览器中，JavaScript 都是编译后运行。程序会被高度优化，运行效率接近二进制程序。而且，JavaScript 引擎正在快速发展，性能将越来越好。</p><p>此外，还有一种 WebAssembly 格式，它是 JavaScript 引擎的中间码格式，全部都是二进制代码。由于跳过了编译步骤，可以达到接近原生二进制代码的运行速度。各种语言（主要是 C 和 C++）通过编译成 WebAssembly，就可以在浏览器里面运行。</p><p><strong>（3）事件驱动和非阻塞式设计。</strong></p><p>JavaScript 程序可以采用事件驱动（event-driven）和非阻塞式（non-blocking）设计，在服务器端适合高并发环境，普通的硬件就可以承受很大的访问量。</p><h3 id="开放性">开放性</h3><p>JavaScript 是一种开放的语言。它的标准 ECMA-262 是 ISO 国际标准，写得非常详尽明确；该标准的主要实现（比如 V8 和 SpiderMonkey 引擎）都是开放的，而且质量很高。这保证了这门语言不属于任何公司或个人，不存在版权和专利的问题。</p><p>语言标准由 TC39 委员会负责制定，该委员会的运作是透明的，所有讨论都是开放的，会议记录都会对外公布。</p><p>不同公司的 JavaScript 运行环境，兼容性很好，程序不做调整或只做很小的调整，就能在所有浏览器上运行。</p><h3 id="社区支持和就业机会">社区支持和就业机会</h3><p>全世界程序员都在使用 JavaScript，它有着极大的社区、广泛的文献和图书、丰富的代码资源。绝大部分你需要用到的功能，都有多个开源函数库可供选用。</p><p>作为项目负责人，你不难招聘到数量众多的 JavaScript 程序员；作为开发者，你也不难找到一份 JavaScript 的工作。</p><h2 id="实验环境">实验环境</h2><p>只要电脑安装了浏览器，就可以用来实验了。可以一边读一边运行示例，加深理解。</p><p>推荐安装 Chrome 浏览器，它的“开发者工具”（Developer Tools）里面的“控制台”（console），就是运行 JavaScript 代码的理想环境。</p><p>进入 Chrome 浏览器的“控制台”，有两种方法。</p><ul><li>直接进入：按下<code>Option + Command + J</code>（Mac）或者<code>Ctrl + Shift + J</code>（Windows / Linux）</li><li>开发者工具进入：开发者工具的快捷键是 F12，或者<code>Option + Command + I</code>（Mac）以及<code>Ctrl + Shift + I</code>（Windows / Linux），然后选择 Console 面板</li></ul><p>进入控制台以后，就可以在提示符后输入代码，然后按<code>Enter</code>键，代码就会执行。如果按<code>Shift + Enter</code>键，就是代码换行，不会触发执行。建议阅读本教程时，将代码复制到控制台进行实验。</p><p>。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greetMe</span>(<span class="params">yourName</span>) {</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">'Hello '</span> + yourName);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="title function_">greetMe</span>(<span class="string">'World'</span>)</span><br><span class="line"><span class="comment">// Hello World</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成与体系结构&#39;</title>
      <link href="/2022/05/07/ji-suan-ji-zu-cheng-yu-ti-xi-jie-gou/"/>
      <url>/2022/05/07/ji-suan-ji-zu-cheng-yu-ti-xi-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1>一、Flynn分类法</h1><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一种常见的计算机体系结构分类方法，主要有两个分类指标</span><br><span class="line">1. 指令流</span><br><span class="line">2. 数据流</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>体系结构类型</th><th>结构</th><th>关键特性</th><th>代表</th></tr></thead><tbody><tr><td>单指令流单数据流<br>SISD</td><td>控制器：一个<br>处理器：一个<br>主存模块：一个</td><td></td><td>单处理器系统</td></tr><tr><td>单指令流多数据流<br>SIMD</td><td>控制器：一个<br>处理器：多个<br>主存模块：多个</td><td>各处理器以异步形式执行同一条指令</td><td>并行处理机<br>阵列处理机<br>超级向量处理机</td></tr><tr><td>多指令流单数据流<br>MISD</td><td>控制器：多个<br>处理器：一个<br>主存模块：多个</td><td>被证明不可能，至少是不实际</td><td>目前没有，有文献称流水线计算机为此类</td></tr><tr><td>多指令流多数据流<br>MIMD</td><td>控制器：多个<br>处理器：多个<br>主存模块：多个</td><td>能够实现作业、任务、指令等各级全面并行</td><td>多处理机系统<br>多计算机</td></tr></tbody></table><h1>二、CISC与RISC</h1><table><thead><tr><th>指令系统类型</th><th>指令</th><th>寻址方式</th><th>实现方式</th><th>其他</th></tr></thead><tbody><tr><td>CISC(复杂)</td><td>数量多，使用频率差别大，可变长格式</td><td>支持多种</td><td>微程序控制技术</td><td>研制周期长</td></tr><tr><td>RISC(精简)</td><td>数量少，使用频率接近，定长格式，大部分为单调周期指令，操作寄存器，只有Load/Store操作内存</td><td>支持方式少</td><td>增加了通用寄存器；<br>硬布线逻辑控制为主；<br>适合采用流水线</td><td>优化编译，有效支持高级语言</td></tr></tbody></table><h1>三、层次化存储结构</h1><p>CPU   $\rightarrow$ 寄存器<br>$\Updownarrow$<br>Cache  $\rightarrow$ 按内容存取<br>$\Updownarrow$<br>内存（主存）<br>$\Updownarrow$<br>外存（辅存）   $\rightarrow$ 硬盘、光盘、u盘等</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从上到下，容量逐渐增大</span><br><span class="line">速度逐渐变慢</span><br><span class="line">单位价格逐渐降低</span><br></pre></td></tr></tbody></table></figure><h1>四、Cache</h1><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Cache的功能：提高CPU数据输入输出的速率，突破冯·诺伊曼瓶颈，即CPU与存储系统间数据传送带宽限制</span><br><span class="line">2. 在计算机的存储系统种，Cache是访问速度最快的层次</span><br><span class="line">3. 使用Cache改善系统性能的依据是程序的局部性原理</span><br></pre></td></tr></tbody></table></figure><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果以h代表Cache的访问命中率，t1表示Cache的周期时间，t2表示主存储器周期时间，以读操作为例，使用“Cache+主存储器”的系统的平均周期为t3，则</span><br><span class="line">                t3 = h * t1 + ( 1 - h ) * t2</span><br><span class="line">其中，( 1 - h )又称为失效率（未命中率）</span><br></pre></td></tr></tbody></table></figure><h1>五、局部性原理</h1><h2 id="1-时间局部性">1. 时间局部性</h2><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果程序中的某条指令一旦执行，不久以后该指令可能再次执行;如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</span><br><span class="line">----被引用过一次的存储器位置在未来会被多次引用（通常在循环中）</span><br></pre></td></tr></tbody></table></figure><h2 id="2-空间局部性">2. 空间局部性</h2><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</span><br><span class="line">----如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</span><br></pre></td></tr></tbody></table></figure><h2 id="3-工作集理论">3. 工作集理论</h2><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把要被频繁访问的页面集合打包起来，并放到Cache使之短时间不被替换，达到高效的目的。</span><br></pre></td></tr></tbody></table></figure><h1>六、主存</h1><h2 id="1-分类">1.分类</h2><ol><li>随机存取存储器<ul><li>DRAM(Dynamic RAM,动态RAM) - SDRAM</li><li>SRAM(Static RAM,静态)</li></ul></li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例子：内存</span><br><span class="line">特点：断电后内存中所有的数据都将被清除掉，无法保存</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>只读存储器<ul><li>MROM(Mask ROM,掩模式ROM)</li><li>PROM(Programmable ROM,一次可编程 ROM)</li><li>EPROM(Erasable PROM,可擦除的 PROM)</li><li>闪速存储器(flash memory,闪存)</li></ul></li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特点:断电后仍能存储相应的信息</span><br></pre></td></tr></tbody></table></figure><h2 id="2-编址">2.编址</h2><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所谓主存的编址就是把芯片组成相应的存储器，在组成时往往需要分析什么样规格的芯片、多少块芯片能够组成按什么方式编址的存储空间。</span><br><span class="line"></span><br><span class="line">  比如 8*4位的存储器，8代表它有8个地址空间，4代表每个地址空间存储有4个比特位的信息。</span><br></pre></td></tr></tbody></table></figure><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">软考题型：</span><br><span class="line"></span><br><span class="line">     内存地址从AC000H到C7FFH,共有_ (1)_ K个地址单元， 如果该内存地址按字(16bit)</span><br><span class="line">编址，由28片存储器芯片构成。已知构成此内存的芯片每片有16K个存储单元，则该芯片每</span><br><span class="line">个存储单元存储_ _(2)_ 位。</span><br><span class="line"></span><br><span class="line">    （1）A. 96     B. 112      C. 132     D. 156</span><br><span class="line"></span><br><span class="line">    （2）A. 4       B. 8          C.16        D. 24</span><br><span class="line"></span><br><span class="line">解答：多少个地址单元：C7FFFH - AC000H + 1  ，C7FFFH + 1 = C8000H , C8000H -  AC000H = 1C000H  , 然后转化单位，（1H = 1024 K = 2^10 K）1C000 ÷ 2^10 = 112 ,故（1）选B。总容量为112K*16bit，设该芯片每个存储单元存储x 位,（112 * 16）/ （28 * 16 * x）= 1 , x = 4 ,故（2）选A</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成与体系结构 </tag>
            
            <tag> 软考 </tag>
            
            <tag> 高级架构师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE入门</title>
      <link href="/2022/04/29/vue-ru-men/"/>
      <url>/2022/04/29/vue-ru-men/</url>
      
        <content type="html"><![CDATA[<h1>1.创建项目</h1><h2 id="vue-create命令">vue create命令</h2><figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create [option] &lt;app-name&gt;</span><br></pre></td></tr></tbody></table></figure><p>创建一个由vue-cle-service提供支持的新项目<br>option选项可以是</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-p, --preset &lt;presetName&gt;： 忽略提示符并使用已保存的或远程的预设选项</span><br><span class="line">-d, --default： 忽略提示符并使用默认预设选项</span><br><span class="line">-i, --inlinePreset &lt;json&gt;： 忽略提示符并使用内联的 JSON 字符串预设选项</span><br><span class="line">-m, --packageManager &lt;command&gt;： 在安装依赖时使用指定的 npm 客户端</span><br><span class="line">-r, --registry &lt;url&gt;： 在安装依赖时使用指定的 npm registry</span><br><span class="line">-g, --git [message]： 强制 / 跳过 git 初始化，并可选的指定初始化提交信息</span><br><span class="line">-n, --no-git： 跳过 git 初始化</span><br><span class="line">-f, --force： 覆写目标目录可能存在的配置</span><br><span class="line">-c, --clone： 使用 git clone 获取远程预设选项</span><br><span class="line">-x, --proxy： 使用指定的代理创建项目</span><br><span class="line">-b, --bare： 创建项目时省略默认组件中的新手指导信息</span><br><span class="line">-h, --help： 输出使用帮助信息</span><br></pre></td></tr></tbody></table></figure><p>例：</p><figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create project-name</span><br></pre></td></tr></tbody></table></figure><p>安装之后启动应用</p><figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></tbody></table></figure><h1>2.Vue3目录结构</h1><p>目录解析</p><table><thead><tr><th>目录/文件</th><th>说明</th></tr></thead><tbody><tr><td>build</td><td>项目构建(webpack)相关代码</td></tr><tr><td>config</td><td>配置目录，包括端口号等。我们初学可以使用默认的。</td></tr><tr><td>node_modules</td><td>npm 加载的项目依赖模块</td></tr><tr><td>src</td><td>这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件</td></tr><tr><td></td><td>assets: 放置一些图片，如logo等。</td></tr><tr><td></td><td>components: 目录里面放了一个组件文件，可以不用。</td></tr><tr><td></td><td>App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。</td></tr><tr><td></td><td>main.js: 项目的核心文件。</td></tr><tr><td></td><td>index.css: 样式文件。</td></tr><tr><td>static</td><td>静态资源目录，如图片、字体等。</td></tr><tr><td>public</td><td>公共资源目录。</td></tr><tr><td>test</td><td>初始测试目录，可删除</td></tr><tr><td>.xxxx文件</td><td>这些是一些配置文件，包括语法配置，git配置等。</td></tr><tr><td>index.html</td><td>首页入口文件，你可以添加一些 meta 信息或统计代码啥的。</td></tr><tr><td>package.json</td><td>项目配置文件。</td></tr><tr><td><a href="http://README.md">README.md</a></td><td>项目的说明文档，markdown 格式</td></tr><tr><td>dist</td><td>使用 npm run build 命令打包后会生成该目录。</td></tr></tbody></table><h1>3. Vue3起步</h1><p>直接在页面引入 vue.global.js<br>Vue3中的应用是通过createApp函数来创建的，语法格式如下</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const app = Vue.createApp({/*选项*/})</span><br></pre></td></tr></tbody></table></figure><p>传递给createApp的选项用于配置根组件。在使用**mount()**挂载应用时，该组件被用作渲染的起点</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.createApp(HelloVueApp).mount('#hello-vue')</span><br></pre></td></tr></tbody></table></figure><p>createApp 的参数是根组件（HelloVueApp），在挂载应用时，该组件是渲染的起点。</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个应用需要被挂载到一个 DOM 元素中，以上代码使用**mount('#hello-vue')**将 Vue 应用 HelloVueApp 挂载到 &lt;div id="hello-vue"&gt;&lt;/div&gt; 中。</span><br><span class="line"> </span><br><span class="line">mount('#hello-vue') 将 Vue 应用 HelloVueApp 挂载到 &lt;div id="hello-vue"&gt;&lt;/div&gt; 中。</span><br><span class="line">{{ }} 用于输出对象属性和函数返回值。</span><br><span class="line">{{ message }} 对应应用中 message 的值。</span><br></pre></td></tr></tbody></table></figure><h3 id="data选项">data选项</h3><p>data 选项是一个函数。Vue 在创建新组件实例的过程中调用此函数。它应该返回一个对象，然后 Vue 会通过响应性系统将其包裹起来，并以 $data 的形式存储在组件实例中。</p>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVN入门&#39;</title>
      <link href="/2022/04/29/svn-ru-men/"/>
      <url>/2022/04/29/svn-ru-men/</url>
      
        <content type="html"><![CDATA[<h1>1.SVN入门简介</h1><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subversion(SVN) 是一个开源的版本控制系統, 也就是说 Subversion 管理着随时间改变的数据。 这些数据放置在一个中央资料档案库(repository) 中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。</span><br></pre></td></tr></tbody></table></figure><h2 id="1-基础概念">1. 基础概念</h2><ol><li>repository（源代码库）:源代码统一存放的地方</li><li>Checkout（提取）:当你手上没有源代码的时候，你需要从repository checkout一份</li><li>Commit（提交）:当你已经修改了代码，你就需要Commit到repository</li><li>Update (更新):当你已经Checkout了一份源代码， Update一下你就可以和Repository上的源代码同步，你手上的代码就会有最新的变更</li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">日常开发过程其实就是这样的（假设你已经Checkout并且已经工作了几天）：Update(获得最新的代码) --&gt;作出自己的修改并调试成功 --&gt; Commit(大家就可以看到你的修改了) 。</span><br><span class="line"></span><br><span class="line">如果两个程序员同时修改了同一个文件呢, SVN 可以合并这两个程序员的改动，实际上SVN管理源代码是以行为单位的，就是说两个程序员只要不是修改了同一行程序，SVN都会自动合并两种修改。如果是同一行，SVN 会提示文件 Conflict, 冲突，需要手动确认。</span><br></pre></td></tr></tbody></table></figure><h2 id="2-主要功能">2. 主要功能</h2><ol><li>目录版本控制</li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVS 只能跟踪单个文件的历史, 不过 Subversion 实作了一个 "虚拟" 的版本控管文件系统, 能够依时间跟踪整个目录的变动。 目录和文件都能进行版本控制。</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>真实的版本历史</li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自从CVS限制了文件的版本记录，CVS并不支持那些可能发生在文件上，但会影响所在目录内容的操作，如同复制和重命名。除此之外，在CVS里你不能用拥有同样名字但是没有继承老版本历史或者根本没有关系的文件替换一个已经纳入系统的文件。在Subversion中，你可以增加（add）、删除（delete）、复制（copy）和重命名（rename），无论是文件还是目录。所有的新加的文件都从一个新的、干净的版本开始。</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>自动提交</li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个提交动作，不是全部更新到了档案库中，就是不完全更新。这允许开发人员以逻辑区间建立并提交变动，以防止当部分提交成功时出现的问题。</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>纳入版本控管的元数据</li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每一个文件与目录都附有一組属性关键字并和属性值相关联。你可以创建, 并儲存任何你想要的Key/Value对。 属性是随着时间来作版本控管的,就像文件內容一样。</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>选择不同的网络层</li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subversion 有抽象的档案库存取概念, 可以让人很容易地实作新的网络机制。 Subversion 可以作为一个扩展模块嵌入到Apache HTTP 服务器中。这个为Subversion提供了非常先进的稳定性和协同工作能力，除此之外还提供了许多重要功能: 举例来说, 有身份认证, 授权, 在线压缩, 以及文件库浏览等等。还有一个轻量级的独立Subversion服务器， 使用的是自定义的通信协议, 可以很容易地通过 ssh 以 tunnel 方式使用。</span><br></pre></td></tr></tbody></table></figure><ol start="6"><li>一致的数据处理方式</li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subversion 使用二进制差异算法来异表示文件的差异, 它对文字(人类可理解的)与二进制文件(人类无法理解的) 两类的文件都一视同仁。 这两类的文件都同样地以压缩形式储存在档案库中, 而且文件差异是以两个方向在网络上传输的。</span><br></pre></td></tr></tbody></table></figure><ol start="7"><li>有效的分支(branch)与标签(tag)</li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在分支与标签上的消耗并不必一定要与项目大小成正比。 Subversion 建立分支与标签的方法, 就只是复制该项目, 使用的方法就类似于硬连接（hard-link）。 所以这些操作只会花费很小, 而且是固定的时间。</span><br></pre></td></tr></tbody></table></figure><ol start="8"><li>Hackability</li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subversion没有任何的历史包袱; 它主要是一群共用的 C 程序库, 具有定义完善的API。这使得 Subversion 便于维护, 并且可被其它应用程序与程序语言使用。</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> svn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架概述&#39;</title>
      <link href="/2022/04/11/spring-kuang-jia-gai-shu/"/>
      <url>/2022/04/11/spring-kuang-jia-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring框架概述">Spring框架概述</h2><ol><li>Spring是轻量级的开源的J2EE框架</li><li>Spring可以解决企业开发的复杂性</li><li>Spring有两个核心部分：IOC和AOP<ol><li>IOC:控制反转，把创建对象过程交给Spring进行管理</li><li>AOP：面向切面，不修改源代码进行功能增强</li></ol></li><li>Spring特点<ol><li>方便解耦，简化开发</li><li>AOP编程支持</li><li>方便程序的测试</li><li>方便集成各种优秀框架</li><li>方便进行事务操作</li><li>降低API使用难度</li><li>Java源码是经典学习范例</li></ol></li></ol><h2 id="IOC容器">IOC容器</h2><ol><li>IOC概念<ol><li>什么是IOC</li></ol> <figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>使用IOC的目的</li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">降低耦合度</span><br></pre></td></tr></tbody></table></figure></li><li>IOC底层原理<ol><li>xml解析、工厂模式、反射</li></ol> <figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 配置对象的xml文件</span><br><span class="line">2. 创建工厂类</span><br><span class="line">3. 解析xml获取class路径</span><br><span class="line">4. 通过反射创建对象</span><br><span class="line">5. 返回该对象</span><br></pre></td></tr></tbody></table></figure></li><li>IOC接口(BeanFactory)<ol><li>IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</li><li>Spring提供IOC容器实现两种方式：(两个接口)<ol><li>BeanFactory</li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用</span><br><span class="line">*加载配置文件时不会创建对象，在获取(使用)对象时才会创建对象</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>ApplicationContext</li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用</span><br><span class="line">*在加载配置文件时就会把配置文件的对象进行创建</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>ApplicationContext接口又实现类</li></ol></li></ol></li><li>IOC操作Bean管理<ol><li>什么是Bean管理</li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bean管理指的是两个操作</span><br><span class="line">1.Spring创建对象</span><br><span class="line">2.Spring注入属性</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>Bean管理操作有两种方式<ol><li>基于xml配置文件方式实现</li></ol><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 在Spring配置文件中，使用bean标签，标签里添加对应属性，就可以实现对象创建</span><br><span class="line">2. 在bean标签有很多属性</span><br><span class="line">   1. id：唯一标识</span><br><span class="line">   2. calss：创建对象的全路径</span><br><span class="line">   3. name：与id类似，可以有特殊字符</span><br><span class="line"></span><br><span class="line">3. 创建对象时，默认是执行无参构造方法完成对象创建</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>基于xml方式注入属性<ol><li><p>DI：依赖注入，就是注入属性</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 使用set方法进行注入</span><br><span class="line">   1. 创建类，定义属性和对应的set方法</span><br><span class="line">   2. 在Spring配置文件中配置对象创建，配置属性注入</span><br><span class="line">2. 使用有参构造注入</span><br><span class="line">   1. 创建类，定义属性，定义有参构造方法</span><br></pre></td></tr></tbody></table></figure></li><li><p>p名称空间注入（了解）</p><ol><li>添加p名称空间在配置文件中</li><li>进行属性注入，在bean标签里面使用p:属性名进行操作</li></ol></li><li><p>xml注入其他类型属性</p><ol><li>字面量<ol><li>null值：使用null标签</li><li>属性值包含特殊符号<ol><li>使用转义字符</li><li>把特殊符号内容写到CDATA中</li></ol></li></ol></li></ol></li><li><p>注入属性-外部bean</p><ol><li>创建两个类：例如service类和DAO类</li><li>在service中调用dao里面的方法</li><li>在Spring配置文件中进行配置</li></ol></li><li><p>注入属性-内部bean和级联赋值</p><ol><li>一对多关系</li><li>在实体之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示</li></ol></li><li><p>注入集合类型属性</p><ol><li>创建类，定义数组、list、map、set类型属性，生成对应set方法</li><li>在spring配置文件中进行配置</li></ol></li></ol></li><li>基于注解方式实现</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 计算机系统概述</title>
      <link href="/2022/03/18/di-yi-zhang-ji-suan-ji-xi-tong-gai-shu/"/>
      <url>/2022/03/18/di-yi-zhang-ji-suan-ji-xi-tong-gai-shu/</url>
      
        <content type="html"><![CDATA[<p>1.1列出并简要定义计算机的4个主要组成部分。</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 处理器（processor）：控制计算机的操作，执行数据处理功能。当只有一个处理器时，</span><br><span class="line">它通常指中央处理单元（CPU）。</span><br><span class="line">2. 内存（main memory）：存储数据和程序。此类存储器通常是易失性的，即当计算机关机</span><br><span class="line">时，存储器的内容会丢失。相反，当计算机关机时，磁盘存储器的内容不会丢失。内存</span><br><span class="line">通常也称为实存储器（real memory）或主存储器（primary memory）。</span><br><span class="line">3. 输入/输出模块（I/O module）：在计算机和外部环境之间移动数据。外部环境由各种外</span><br><span class="line">部设备组成，包括辅助存储器设备（如硬盘）、通信设备和终端。</span><br><span class="line">4. 系统总线（system bus）：为处理器、内存和输入/输出模块间提供通信的设施。</span><br></pre></td></tr></tbody></table></figure><p>1.2定义处理器寄存器的两种主要类别。</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 用户可见寄存器:优先使用这些寄存器,可以使机器语言或者汇编语言的程序员减少对主存储器的访问次数。对高级语言而言，由优化编译器负责决定把哪些变量应该分配给主存储器。一些些高级语言,如C语言,允许程序言建议编译器把哪些变量保存在寄存器中。</span><br><span class="line">2. 控制和状态寄存器:用以控制处理器的操作,且主要被具有特权的操作系统例程使用,以控制程序的执行。</span><br></pre></td></tr></tbody></table></figure><p>1.3一般而言，一条机器指令能指定的4种不同操作是什么</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 处理器-寄存器:数据</span><br><span class="line">以从处理器传送到存储器,或者从存储器传送到处理器。</span><br><span class="line">2. 处理器-I/O:通过处理器和I/O模块间的数据传送,数据可以输出到外部设备,或者从外部设备输入数据。</span><br><span class="line">3. 数据处理:处理器可以执行很多关于数据的算术操作或逻辑操作。</span><br><span class="line">4. 控制:某些指令可以改变执行顺序。</span><br></pre></td></tr></tbody></table></figure><p>1.4什么是中断?</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其他模块（I/O,存储器）终端处理器正常处理过程的机制</span><br></pre></td></tr></tbody></table></figure><p>1.5多个中断的处理方式是什么?</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一种：当正在处理一个中断时，禁止再次发生中断</span><br><span class="line"></span><br><span class="line">第二种：定义中断优先级，允许高优先级中断打断低优先级的中断处理器的运行</span><br></pre></td></tr></tbody></table></figure><p>1.6内存层次各个元素间的特征是什么?</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">价格</span><br><span class="line">容量</span><br><span class="line">访问时间</span><br><span class="line"></span><br><span class="line">自上而下看时：</span><br><span class="line">a.每“位”的价格递减</span><br><span class="line">b.容量递增</span><br><span class="line">c.存取时间递增</span><br><span class="line">d.处理器访问存储器的频率递减</span><br></pre></td></tr></tbody></table></figure><p>1.7什么是高速缓存?</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">高速缓冲时比主存小而快的存储器，用以协调主存跟处理器，作为最近的储存地址的缓冲区</span><br></pre></td></tr></tbody></table></figure><p>1.8多处理器系统和多核系统的区别是什么?</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、概念上的区别：</span><br><span class="line"></span><br><span class="line">多处理器系统中包含多个单核处理器，就是说电脑和处理器有多个，但电脑的处理器是单核的；多核处理器系统指系统中只有一个多核心的处理器，也就是说电脑只有一个处理器，但是这个处理器是多核的。</span><br><span class="line"></span><br><span class="line">2、资源利用率的区别：</span><br><span class="line"></span><br><span class="line">对于多处理器系统而言，它们在执行命令的时候多个处理器之间的通信手段是电脑主板上的总线。而对于多核系统而言，多个核心处理器之间通信时通过CPU内部总线进行信息的交互的。对于执行效率而言，多核处理器要优于多个处理器。</span><br><span class="line"></span><br><span class="line">3、线程控制上的区别：</span><br><span class="line"></span><br><span class="line">计算机在启动之后，一个进程最少包含一个主线程，如果这个主线程结束了，那么这个进程也就终止执行了，主线程是以函数的形式提供给操作系统的。对于并行计算是在多处理器的情况下，操作系统把多个线程分配给响应的处理器，然后各自执行任务。</span><br></pre></td></tr></tbody></table></figure><p>1.9空间局部性和时间局部性之间的区别是什么?</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">时间局部性:</span><br><span class="line">如果在某一点时访问了存储器的特定位置，则很可能在不久的将来将再次访问相同的位置。在对相同存储器位置的相邻访问之间存在时间接近性。</span><br><span class="line">在这种情况下，通常努力将访问过的数据的副本存储在可以被更快访问的特殊存储器中。时间局部性是空间局部性的特殊情况，即当预期位置与当前位置相同时。</span><br><span class="line"></span><br><span class="line">空间局部性:</span><br><span class="line">如果特定存储位置在特定时间被访问，则很可能在不久的将来访问附近的存储位置。在这种情况下，通常尝试猜测当前访问周围的区域的大小和形状，对于该区域，值得准备更快的访问。</span><br></pre></td></tr></tbody></table></figure><p>1.10开发空间局部性和时间局部性的策略是什么?</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程运行时，在一段时间里，程序的执行往往呈现高度的局部性，包括时间局部性和空间局部性。时间局部性是一旦一个指令被执行了，则在不久的将来，它可能再被执行。空间局部性是一旦一个指令一个存储单元被访问，那么它附近的单元也将很快被访问。程序的局部性原理是虚拟存储技术引入的前提。虚拟存储的实现原理是，当进程要求运行时，不是将它全部装入内存，而是将其一部分装入内存，另一部分暂时不装入内存。</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 习题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell编程概述</title>
      <link href="/2022/02/01/shell-bian-cheng/"/>
      <url>/2022/02/01/shell-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1>1. Shell编程概述</h1><h2 id="1-1-Shell名词解释">1.1 Shell名词解释</h2><ul><li><p>Kernel</p><ul><li>Linux内核主要是为了和硬件打交道</li></ul></li><li><p>Shell</p><ul><li>命令解释器（command interpreter）</li><li>Shell 是一个用C语言编写的程序，它时用户使用Linux的桥梁。Shell既是一种命令语言，又是一种程序设计语言</li><li>Shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务</li></ul></li><li><p>Shell两大主流</p><ul><li>sh:<ul><li>Bourne shell (sh) , Solaris,hpux默认Shell</li><li>Bourne again sell(bash),Linux默认shell</li></ul></li><li>csh<ul><li>C shell (csh)</li><li>tc shell (tcsh)</li></ul></li></ul></li><li><p><strong>#!</strong> 声明</p><ul><li>告诉系统其后路径所指定的程序即是解释此脚本文件的Shell程序</li><li><pre><code class="language-sh">  #!/bin/bash  echo "Hello World !"<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">##  1.2 Shell脚本的执行</span><br><span class="line">- 输入脚本的绝对路径或相对路径</span><br><span class="line">    - /root/helloworld.sh</span><br><span class="line">    - ./helloworld.sh</span><br><span class="line">    - 执行的必须是一个可执行文件</span><br><span class="line">- bash或sh+脚本</span><br><span class="line">- sh hellowrld.sh</span><br><span class="line">- 当脚本没有x权限时，root和文件所有者通过该方式可以正常执行</span><br><span class="line">- 在脚本的路径前再加"."或source</span><br><span class="line">    - source helloworld.sh</span><br><span class="line">- 区别</span><br><span class="line">    - 绝对路径、相对路径或者bash、sh会新开一个bash，不同bash中的变量无法共享</span><br><span class="line">    - 第三种是在同一个shell里执行的</span><br><span class="line">- export：可以将当前进程的变量传递给子进程去使用</span><br><span class="line">    - 将来配置profile的时候，所有的变量前必须加export</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  Shell 基础入门</span><br><span class="line">##  2.1 Shell 变量</span><br><span class="line">- 定义变量时，变量名不加美元符号</span><br><span class="line">    - 命名只能使用英文字母，数字和下划线，首个字母不能以数字开头。</span><br><span class="line">    - 中间不能有空格，可以使用下划线</span><br><span class="line">    - 不能使用标点符号。</span><br><span class="line">    - 不能使用bash里的关键字(可用help命令查看保留关键字)</span><br><span class="line">- 变量的类型</span><br><span class="line">    - 局部变量</span><br><span class="line">        - 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量</span><br><span class="line">    - 环境变量</span><br><span class="line">        - 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行</span><br><span class="line">    - Shell变量</span><br><span class="line">        - shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分时局部变量</span><br><span class="line">-</span><br><span class="line">```sh</span><br><span class="line"># 变量的声明</span><br><span class="line">name="zhangsan"</span><br><span class="line">for file in `ls /etc`</span><br><span class="line">或</span><br><span class="line">for file in $(ls /etc)</span><br><span class="line"></span><br><span class="line"># 变量的调用</span><br><span class="line">echo $name</span><br><span class="line">echo ${name}</span><br><span class="line"></span><br><span class="line">for skill in Ada Coffe Action Java; do</span><br><span class="line">    echo "I am good at ${skill}Script"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 只读变量 /bin/sh: NAME: This variable is read only</span><br><span class="line">url="https://www.google.com"</span><br><span class="line">readonly url</span><br><span class="line">url="https://www.runoob.com"</span><br><span class="line"></span><br><span class="line"># 删除变量</span><br><span class="line">unset name</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript类</title>
      <link href="/2022/01/01/typescript-lei/"/>
      <url>/2022/01/01/typescript-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="TypeScript类">TypeScript类</h2><p>TypeScript 是面向对象的 JavaScript。<br>类描述了所创建的对象共同的属性和方法。<br>TypeScript 支持面向对象的所有特性，比如 类、接口等。<br>TypeScript 类定义方式如下：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">class_name</span> {</span><br><span class="line"><span class="comment">//类作用域</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>定义类的关键字为 class，后面紧跟类名，类可以包含以下几个模块（类的数据成员）：</p><ol><li>字段 − 字段是类里面声明的变量。字段表示对象的有关数据。</li><li>构造函数 − 类实例化时调用，可以为类的对象分配内存。</li><li>方法 − 方法为对象要执行的操作。</li></ol><h3 id="创建实例化对象">创建实例化对象</h3><p>使用new关键字来实例化类的对象</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object_name = <span class="keyword">new</span> <span class="title function_">class_name</span>([<span class="variable language_">arguments</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//类实例化时会调用构造函数</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">""</span>engine <span class="number">1</span><span class="string">""</span>)</span><br><span class="line"> <span class="comment">//访问属性</span></span><br><span class="line"> obj.<span class="property">field_name</span></span><br><span class="line"> obj.<span class="title function_">function_name</span>()</span><br></pre></td></tr></tbody></table></figure><h3 id="类的继承">类的继承</h3><p>Typescript支持继承类，即我们可以在创建类的时候继承一个已存在的类，这个已存在的类称为父类，继承它的类为子类<br>类继承使用关键字extends，子类除了不能继承父类的私有成员（方法和属性）和构造函数，其他的都可以继承<br>TypeScript一次只能继承一个类，不支持继承多个类，但是支持多重继承（A继承B，B继承C）</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">child_class_name</span> <span class="keyword">extends</span> <span class="title class_ inherited__">parent_class_name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> { </span><br><span class="line">   <span class="title class_">Area</span>:<span class="built_in">number</span> </span><br><span class="line">   </span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">a:<span class="built_in">number</span></span>) { </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">Area</span> = a </span><br><span class="line">   } </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> { </span><br><span class="line">   <span class="title function_">disp</span>():<span class="built_in">void</span> { </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span>圆的面积:  <span class="string">""</span>+<span class="variable language_">this</span>.<span class="property">Area</span>) </span><br><span class="line">   } </span><br><span class="line">}</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">223</span>); </span><br><span class="line">obj.<span class="title function_">disp</span>()</span><br></pre></td></tr></tbody></table></figure><h3 id="继承类的方法重写">继承类的方法重写</h3><p>类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写<br>其中super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrinterClass</span> { </span><br><span class="line">   <span class="title function_">doPrint</span>():<span class="built_in">void</span> {</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span>父类的 <span class="title function_">doPrint</span>() 方法。<span class="string">""</span>) </span><br><span class="line">   } </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringPrinter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">PrinterClass</span> { </span><br><span class="line">   <span class="title function_">doPrint</span>():<span class="built_in">void</span> { </span><br><span class="line">      <span class="variable language_">super</span>.<span class="title function_">doPrint</span>() <span class="comment">// 调用父类的函数</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span>子类的 <span class="title function_">doPrint</span>()方法。<span class="string">""</span>)</span><br><span class="line">   } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="static-关键字">static 关键字</h3><p>static关键字用于定义类的数据成员（属性和方法）为静态的，静态成员可以直接通过类名调用</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StaticMem</span> {  </span><br><span class="line">   <span class="keyword">static</span> <span class="attr">num</span>:<span class="built_in">number</span>; </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span> <span class="title function_">disp</span>():<span class="built_in">void</span> { </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span>num 值为 <span class="string">""</span>+ <span class="title class_">StaticMem</span>.<span class="property">num</span>) </span><br><span class="line">   } </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="title class_">StaticMem</span>.<span class="property">num</span> = <span class="number">12</span>     <span class="comment">// 初始化静态变量</span></span><br><span class="line"><span class="title class_">StaticMem</span>.<span class="title function_">disp</span>()       <span class="comment">// 调用静态方法</span></span><br></pre></td></tr></tbody></table></figure><h3 id="instanceof运算符">instanceof运算符</h3><p>instanceof 运算符用于判断对象是否是指定的类型，如果是返回 true，否则返回 false。</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>{ } </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Person</span>() </span><br><span class="line"><span class="keyword">var</span> isPerson = obj <span class="keyword">instanceof</span> <span class="title class_">Person</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span>obj 对象是 <span class="title class_">Person</span> 类实例化来的吗？ <span class="string">""</span> + isPerson);</span><br></pre></td></tr></tbody></table></figure><h3 id="访问控制修饰符">访问控制修饰符</h3><p>TypeScript 中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。TypeScript 支持 3 种不同的访问权限。</p><ul><li>public（默认） : 公有，可以在任何地方被访问。</li><li>protected : 受保护，可以被其自身以及其子类和父类访问。</li><li>private : 私有，只能被其定义所在的类访问。</li></ul><p>以下实例定义了两个变量 str1 和 str2，str1 为 public，str2 为 private，实例化后可以访问 str1，如果要访问 str2 则会编译错误</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Encapsulate</span> { </span><br><span class="line">   <span class="attr">str1</span>:<span class="built_in">string</span> = <span class="string">""</span>hello<span class="string">""</span> </span><br><span class="line">   <span class="keyword">private</span> <span class="attr">str2</span>:<span class="built_in">string</span> = <span class="string">""</span>world<span class="string">""</span> </span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Encapsulate</span>() </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">str1</span>)     <span class="comment">// 可访问 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">str2</span>)   <span class="comment">// 编译错误， str2 是私有的</span></span><br></pre></td></tr></tbody></table></figure><h3 id="类和接口">类和接口</h3><p>类可以实现接口，使用关键字implement，并将interface字段作为类的属性使用</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ILoan</span> { </span><br><span class="line">   <span class="attr">interest</span>:<span class="built_in">number</span> </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgriLoan</span> <span class="keyword">implements</span> <span class="title class_">ILoan</span> { </span><br><span class="line">   <span class="attr">interest</span>:<span class="built_in">number</span> </span><br><span class="line">   <span class="attr">rebate</span>:<span class="built_in">number</span> </span><br><span class="line">   </span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">interest:<span class="built_in">number</span>,rebate:<span class="built_in">number</span></span>) { </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">interest</span> = interest </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">rebate</span> = rebate </span><br><span class="line">   } </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">AgriLoan</span>(<span class="number">10</span>,<span class="number">1</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span>利润为 : <span class="string">""</span>+obj.<span class="property">interest</span>+<span class="string">""</span>，抽成为 : <span class="string">""</span>+obj.<span class="property">rebate</span> )</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE学前准备</title>
      <link href="/2022/01/01/vue-xue-qian-zhun-bei/"/>
      <url>/2022/01/01/vue-xue-qian-zhun-bei/</url>
      
        <content type="html"><![CDATA[<h1>概述</h1><p>VUE是一套用户构建用户界面的<em><strong>渐进式框架</strong></em>，发布与2014年2月，与其他大型框架不同的是，VUE被设计为可以自底向上逐层应用，VUE的核心库只关注视图层，不仅易于上手，还便于与地方哭或既有项目整合</p><p><a href="https://cn.vuejs.org/v2/guide/#">https://cn.vuejs.org/v2/guide/#</a> 前端知识体系</p><h2 id="前端三要素">前端三要素</h2><ul><li>HTML（结构）：超文本标记语言，决定网页的结构和内容</li><li>CSS（表现）：层叠样式表，设定网页的表现样式</li><li>JavaScript（行为）：是一种弱类型脚本语言，其源代码不需要经过编译，而是由浏览器解释运行，用于控制网页的行为</li></ul><h2 id="结构层（HTML）">结构层（HTML）</h2><h2 id="表现层（CSS）">表现层（CSS）</h2><p>CSS层叠样式表示一门标记语言，并不是编程语言，因此不可以自定义变量，不也已引用等，不具备任何语法支持</p><p>缺点：</p><ul><li>语法不够强大，无法嵌套书写，导致模块化开发中需要书写很多重复的选择器</li><li>没有变量和合理的样式复用机制，是的逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护</li></ul><p>解决：</p><p>使用css预处理器的工具，提供CSS缺失的样式复用机制，减少荣誉代码，提高样式代码的可维护性，大大提高了前端样式上的开发效率</p><h3 id="CSS预处理器">CSS预处理器</h3><p>CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加一些编程特性，将CSS作为目标生成文件，让后开发者就只要使用这种语言进行CSS的编码工作。</p><p>***本质就是用一种专门的编程语言，进行Web的页面样式设计，再通过编译器转换为正常的CSS文件，供项目使用</p><ul><li>SASS：基于Ruby没通过服务器端吃力，功能强大，解析效率高，需要学习Ruby语言，上手难度较大</li><li>LESS：基于NodeJS，通过客户端处理，使用简单，功能比SASS简单，解析效率也低于SASS，但实际开发中足够了，建议使用</li></ul><h2 id="行为层（JavaScript）">行为层（JavaScript）</h2><p>JavaScript是一门弱类型脚本语言，其源代码在发往客户端运行之前不需要经过编译，而是将文本格式的字符代码发送给浏览器由浏览器解释运行</p><h3 id="Native原生JS开发">Native原生JS开发</h3><p>原生JS开发，也就是让我们按照<em><strong>ECMAScript</strong></em>标准的开发方式，简称ES，特点是所有浏览器都支持</p><p>ES3~ES9</p><p>ES5全浏览器支持<br>ES6常用，当前主流版本，webpack打包成ES5支持<br>ES9（草案阶段）区别就是逐步增加新特性</p><p>TypeScript微软的标准</p><p>TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程，</p><p>改语言的特点就是除了具备ES的特性之外还奶入了许多不在标准范围内的新特性，所以会导致很多浏览器不能直接支持TypeScript语法，需要编译后（编译成JS）才能被浏览器正确执行</p><h2 id="JavaScript框架">JavaScript框架</h2><ul><li>jQuery：简化了DOM操作，缺点是DOM操作太频繁，影响前端性能，但是兼容IE6、7、8</li><li>Angular：Google收购的前端框架，由一群Java程序员开发，特点是将后台的MVC模式搬到了前端并增加了<em><strong>模块化开发</strong></em>的理念，采用TypeScript语法开发，对前端不友好，对后端程序员友好，版本迭代不合理</li><li>React：Facebook出品，一款高性能JS前端框架，提出了新概念<strong>虚拟DOM</strong>用于减少真实DOM操作，在内存中模拟DOM操作，有效提升了前端渲染效率，缺点是使用复杂，需要额外学习<strong>JSX</strong>语言</li><li>Vue：渐进式JavaScript框架，渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性，综合了Angular（模块化）和React（虚拟DOM）的优点</li><li>Axios：前端通信框架；因为VUE就是为了处理Dom，所以并不具备通信能力，此时就需额外使用一个通信框架和服务器交互；当然也可以直接选择使用jQuery提供的AJAX通信功能</li></ul><h2 id="UI框架">UI框架</h2><ul><li>Ant-Design:阿里巴巴出品，基于React的UI框架</li><li>ElementUi、iview、ice：饿了么出品，基于VUE的UI框架</li><li>Bootstrap：Twitter推测出的一个用于前端开发的开源工具包</li><li>AmazeUI：一款HTML5跨屏前端框架</li></ul><h2 id="JavaScript构建工具">JavaScript构建工具</h2><ul><li>Babel：JS编译工具，主要用于浏览器不支持的ES新特性，比如用于编译TypeScript</li><li>WebPack：模块打包器，主要作用是打包、压缩、合并及按序加载</li></ul><h1>三端统一</h1><h2 id="混合开发（Hybrid-App）">混合开发（Hybrid App）</h2><p>主要目的是实现一套代码三端统一（PC、Android：.apk、IOS：.ipa）并能够调用到设备底层硬件，打包方式主要有两种：</p><ul><li>云打包：Hbuild-&gt;HBulidX，DCloud出品；API Cloud</li><li>本地打包：Cordova（前身是PhoneGap）</li></ul><h1>后端技术</h1><p>前端人员为了方便开发也需要掌握一定的后端技术，但Java后台人员指导后台知识体系机器庞大复杂，所以为了方便前端人员开发后台应用，就出现了NodeJS这样的技术</p><p>NodeJS框架以及项目管理工具如下：</p><ul><li>Express：NodeJS框架</li><li>Koa：Express简化版</li><li>NPM：项目综合管理工具，类似于Maven</li><li>YARN：NPM的替代方案，类似于Maven和Gradle的关系</li></ul><h2 id="主流前端框架">主流前端框架</h2><p>Vue.js</p><h3 id="iView">iView</h3><p>iview是一个强大的基于Vue的UI库，有很多实用的基础组件比elementui的组件更丰富，主要服务于PC界面的中后台产品。使用单文件的Vue组件化开发模式，基于npm+webpack+babel开发，支持ES2015高质量、功能丰富友好的API，自由灵活地使用空间<br><strong>属于前端主流框架，选型时可考虑使用，主要特点是移动端支持比较多</strong></p><h3 id="ElementUI">ElementUI</h3><p>Element是饿了么前端开源维护的VueUI组件库，组件齐全，基本涵盖后台所需的所有组件，文档讲解详细，例子也很丰富。主要用于开发PC端的页面，是一个质量比较高的VueUI组件库</p><p><strong>属于前端主流框架，选型时可考虑使用，主要特点是桌面端支持比较多</strong></p><h3 id="ICE">ICE</h3><p>飞冰是阿里巴巴团队基于React/Angular/Vue的中后台应用解决方案，在阿里巴巴内部，已经有270多个来自几乎所有BU的项目在使用，飞冰包含了一套从设计端到开发1端的完整链路，帮助用户快速搭建属于自己的中后台应用。</p><p><strong>主要组件还是以React为主</strong></p><h1>后端为主的MVC时代</h1><p>为了降低开发的复杂度，以后端为出发点</p><p>例：SpringMVC流程</p><ol><li>发起请求到前端控制器</li><li>前端控制器请求HandlerMapping查找Handler，可以根据xml配置、注解进行查找对应的处理器，并返回给前端控制器</li><li>前端控制器根据返回的数据查找对应的处理器并执行</li><li>处理器执行完给支配器返回ModelAndView</li><li>前端控制请请求视图解析器进行解析，根据逻辑视图名解析成真正的视图</li><li>视图解析器向前端控制器返回view</li><li>前端控制器进行视图渲染，视图渲染将模型数据（在ModelAndView对象中）填充到request域</li><li>前端控制器向用户响应结果</li></ol><h1>前端为主的MV*时代</h1><ul><li>MVC（同步通信为主）：Model、View、Controller</li><li>MVP（异步通信为主）：Model、View、Presenter</li><li>MVVM（异步通信为主：Model、View、ViewModel</li></ul><p>为了降低前端开发复杂度，涌现了大量的前端框架，比如：AngularJS、React、Vue.JS、EmberJS等，这些框架总的原则是先按类型分层，比如Templates、Controllers、Models，然后在在层内做分切</p>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript接口</title>
      <link href="/2022/01/01/typescript-jie-kou/"/>
      <url>/2022/01/01/typescript-jie-kou/</url>
      
        <content type="html"><![CDATA[<h2 id="接口">接口</h2><p>接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="keyword">interface</span> interface_name{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> { </span><br><span class="line">    <span class="attr">firstName</span>:<span class="built_in">string</span>, </span><br><span class="line">    <span class="attr">lastName</span>:<span class="built_in">string</span>, </span><br><span class="line">    <span class="attr">sayHi</span>: <span class="function">()=&gt;</span><span class="built_in">string</span> </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> <span class="attr">customer</span>:<span class="title class_">IPerson</span> = { </span><br><span class="line">    <span class="attr">firstName</span>:<span class="string">""</span><span class="title class_">Tom</span><span class="string">""</span>,</span><br><span class="line">    <span class="attr">lastName</span>:<span class="string">""</span><span class="title class_">Hanks</span><span class="string">""</span>, </span><br><span class="line">    <span class="attr">sayHi</span>: ():<span class="function"><span class="params">string</span> =&gt;</span>{<span class="keyword">return</span> <span class="string">""</span><span class="title class_">Hi</span> there<span class="string">""</span>} </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span><span class="title class_">Customer</span> 对象 <span class="string">""</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(customer.<span class="property">firstName</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(customer.<span class="property">lastName</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(customer.<span class="title function_">sayHi</span>())  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> <span class="attr">employee</span>:<span class="title class_">IPerson</span> = { </span><br><span class="line">    <span class="attr">firstName</span>:<span class="string">""</span><span class="title class_">Jim</span><span class="string">""</span>,</span><br><span class="line">    <span class="attr">lastName</span>:<span class="string">""</span><span class="title class_">Blakes</span><span class="string">""</span>, </span><br><span class="line">    <span class="attr">sayHi</span>: ():<span class="function"><span class="params">string</span> =&gt;</span>{<span class="keyword">return</span> <span class="string">""</span><span class="title class_">Hello</span>!!!<span class="string">""</span>} </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span><span class="title class_">Employee</span>  对象 <span class="string">""</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(employee.<span class="property">firstName</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(employee.<span class="property">lastName</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="联合类型接口">联合类型接口</h2><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">RunOptions</span> { </span><br><span class="line">    <span class="attr">program</span>:<span class="built_in">string</span>; </span><br><span class="line">    <span class="attr">commandline</span>:<span class="built_in">string</span>[]|<span class="built_in">string</span>|(<span class="function">()=&gt;</span><span class="built_in">string</span>); </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="comment">// commandline 是字符串</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">options</span>:<span class="title class_">RunOptions</span> = {<span class="attr">program</span>:<span class="string">""</span>test1<span class="string">""</span>,<span class="attr">commandline</span>:<span class="string">""</span><span class="title class_">Hello</span><span class="string">""</span>}; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(options.<span class="property">commandline</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// commandline 是字符串数组</span></span><br><span class="line">options = {<span class="attr">program</span>:<span class="string">""</span>test1<span class="string">""</span>,<span class="attr">commandline</span>:[<span class="string">""</span><span class="title class_">Hello</span><span class="string">""</span>,<span class="string">""</span><span class="title class_">World</span><span class="string">""</span>]}; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(options.<span class="property">commandline</span>[<span class="number">0</span>]); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(options.<span class="property">commandline</span>[<span class="number">1</span>]);  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// commandline 是一个函数表达式</span></span><br><span class="line">options = {<span class="attr">program</span>:<span class="string">""</span>test1<span class="string">""</span>,<span class="attr">commandline</span>:<span class="function">()=&gt;</span>{<span class="keyword">return</span> <span class="string">""</span>**<span class="title class_">Hello</span> <span class="title class_">World</span>**<span class="string">""</span>;}}; </span><br><span class="line"><span class="comment">//方法需要额外定义接收</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">fn</span>:<span class="built_in">any</span> = options.<span class="property">commandline</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>());</span><br></pre></td></tr></tbody></table></figure><h2 id="接口和数组">接口和数组</h2><p>接口中我们可以将数组的索引值和元素设置为不同的类型，索引值可以是数字或字符串</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> namelist { </span><br><span class="line">   [<span class="attr">index</span>:<span class="built_in">number</span>]:<span class="built_in">string</span> </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> <span class="attr">list2</span>:namelist = [<span class="string">""</span><span class="title class_">John</span><span class="string">""</span>,<span class="number">1</span>,<span class="string">""</span><span class="title class_">Bran</span><span class="string">""</span>] <span class="comment">// 错误元素 1 不是 string 类型</span></span><br><span class="line"><span class="keyword">interface</span> ages { </span><br><span class="line">   [<span class="attr">index</span>:<span class="built_in">string</span>]:<span class="built_in">number</span> </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> <span class="attr">agelist</span>:ages; </span><br><span class="line">agelist[<span class="string">""</span><span class="title class_">John</span><span class="string">""</span>] = <span class="number">15</span>   <span class="comment">// 正确 </span></span><br><span class="line">agelist[<span class="number">2</span>] = <span class="string">""</span>nine<span class="string">""</span>   <span class="comment">// 错误</span></span><br></pre></td></tr></tbody></table></figure><p><em><strong>个人理解</strong></em></p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有点像java中的linkedhashmap结构</span><br></pre></td></tr></tbody></table></figure><h2 id="接口继承">接口继承</h2><p>接口继承就是说接口可以通过其他接口来扩展自己<br>TypeScript允许接口继承多个接口<br>继承关键字<strong>extends</strong>。</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单接口继承语法格式</span></span><br><span class="line">child_interface_name <span class="keyword">extends</span> super_interface_name</span><br><span class="line"></span><br><span class="line"><span class="comment">//多接口继承语法格式</span></span><br><span class="line">child_interface_name <span class="keyword">extends</span> super_interface_name1,superinterface_name2,.........</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript基础语法</title>
      <link href="/2022/01/01/typescript-ji-chu-yu-fa-ru-men/"/>
      <url>/2022/01/01/typescript-ji-chu-yu-fa-ru-men/</url>
      
        <content type="html"><![CDATA[<h1>一.基础数据类型</h1><table><thead><tr><th>数据类型</th><th>关键字</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>任意类型</td><td>any</td><td>声明为any的变量可以用来表示整数和分数</td><td></td></tr><tr><td>字符串类型</td><td>string</td><td>一个字符系列，使用单引号（‘’)或双引号(“”“”)来表示字符串类型。反引号（`)来定义多行文本和内嵌表达式</td><td>let num : number = 10;</td></tr><tr><td>布尔类型</td><td>boolean</td><td>表示逻辑值true和false</td><td>let flag : boolean = true</td></tr><tr><td>数组类型</td><td>无</td><td>声明变量为数组</td><td>let arr: number[] =[1,2];</td></tr><tr><td>元组</td><td>无</td><td>元组类型用来表示一直元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同</td><td>let x: [string,number];</td></tr><tr><td>枚举</td><td>enum</td><td>枚举类型用于定义数值集合</td><td>enum Color {Red,Blue}</td></tr><tr><td>void</td><td>void</td><td>用于表示方法返回值类型，表示该方法没有返回值</td><td></td></tr><tr><td>null</td><td>null</td><td>表示对象值缺失</td><td></td></tr><tr><td>undefined</td><td>undefined</td><td>用于初始化变量为一个未定义的值</td><td></td></tr><tr><td>never</td><td>never</td><td>never是其他类型（包括 null 和undefined)的子类型，代表从不会出现的值</td><td></td></tr></tbody></table><h2 id="1-Any类型">1. Any类型</h2><p>任意值是TypeScript针对编程时类型不明确的变量使用的一种数据类型，它常用于以下三种情况。</p><ol><li>变量的值会动态改变是，比如来自用户的输入，任意类型可以让这些变量跳过编译阶段的类型检查</li></ol><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="number">1</span>;</span><br><span class="line">x = <span class="string">'Is time'</span>;</span><br><span class="line">x = <span class="literal">false</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="2-Null和Undefined">2. Null和Undefined</h2><h3 id="null">null</h3><p>在 JavaScript 中 null 表示 ““什么都没有””。<br>null是一个只有一个值的特殊类型。表示一个空对象引用。<br>用 type of 检测 null 返回是 object。</p><h3 id="undefined">undefined</h3><p>在 JavaScript 中, undefined 是一个没有设置值的变量。</p><p>type of一个没有值的变量会返回 undefined。</p><p>Null 和 Undefined 是其他任何类型（包括 void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。而在TypeScript中启用严格的空校验（–strictNullChecks）特性，就可以使得null 和 undefined 只能被赋值给 void 或本身对应的类型</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启用严格的空校验(--strictNullChecks)</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// 运行正确</span></span><br><span class="line">x = <span class="literal">undefined</span>;    <span class="comment">// 运行错误</span></span><br><span class="line">x = <span class="literal">null</span>;    <span class="comment">// 运行错误</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用 --strictNullChecks</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// 运行正确</span></span><br><span class="line">x = <span class="literal">undefined</span>;    <span class="comment">// 运行正确</span></span><br><span class="line">x = <span class="literal">null</span>;    <span class="comment">// 运行正确</span></span><br></pre></td></tr></tbody></table></figure><h2 id="3-never类型">3. never类型</h2><p>never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。这意味着声明为 never 类型的变量只能被 never 类型所赋值，在函数中它通常表现为抛出异常或无法执行到终止点（例如无限循环）</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行错误，数字类型不能转为 never 类型</span></span><br><span class="line">x = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行正确，never 类型可以赋值给 never类型</span></span><br><span class="line">x = (<span class="function">()=&gt;</span>{ <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'exception'</span>)})();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行正确，never 类型可以赋值给 数字类型</span></span><br><span class="line">y = (<span class="function">()=&gt;</span>{ <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">'exception'</span>)})();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 never 的函数可以是抛出异常的情况</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="built_in">never</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(message);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 never 的函数可以是无法被执行到的终止点的情况</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loop</span>(<span class="params"></span>): <span class="built_in">never</span> {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1>二、TypeScript 变量声明</h1><ol><li>声明变量的类型及初始值：</li></ol><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [变量名] : [类型] = 值;</span><br><span class="line"><span class="keyword">var</span> <span class="attr">uname</span>:<span class="built_in">string</span> = <span class="string">""</span>time<span class="string">""</span>;</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>声明变量的类型，但没有初始值，变量值会设置为 undefined：</li></ol><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [变量名]: [类型];</span><br><span class="line"><span class="keyword">var</span> <span class="attr">uname</span>:<span class="built_in">string</span>;</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>声明变量并初始值，但不设置类型，该变量可以是任意类型：</li></ol><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [变量名] = 值;</span><br><span class="line"><span class="keyword">var</span> uname = <span class="string">""</span>time<span class="string">""</span>;</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>声明变量没有设置类型和初始值，类型可以是任意类型，默认初始值为 undefined：</li></ol><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [变量名];</span><br><span class="line"><span class="keyword">var</span> uname;</span><br></pre></td></tr></tbody></table></figure><p><strong>注意</strong>:变量不要使用 name 否则会与 DOM 中的全局 window 对象下的 name 属性出现了重名。</p><h3 id="类型断言">类型断言</h3><p>类型断言可以用来手动指定一个值的类型，即允许变量从一种类型更改为另一种类型。<br>语法格式：</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt; 值</span><br></pre></td></tr></tbody></table></figure><p>或</p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">值 as 类型</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">var</span> <span class="attr">str2</span>:<span class="built_in">number</span> = &lt;<span class="built_in">number</span>&gt;&lt;<span class="built_in">any</span>&gt; str <span class="comment">//str、str2是string类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2)</span><br></pre></td></tr></tbody></table></figure><p><em><strong>个人理解</strong></em></p><figure class="highlight txt"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类型断言不是类型强制转换，而是类型选择。只是在特定地点强制认为该变量的类型为断言类型。</span><br><span class="line">例如：</span><br><span class="line">val变量为联合类型number和string,即val既是number类型，也是string类型，当代码中需要返回val的长度时，val.length就会报错，因为number类型没有length方法。</span><br><span class="line">访问联合类型值的属性时，这个属性必须是所有可能类型的共有属性</span><br></pre></td></tr></tbody></table></figure><h3 id="变量作用域">变量作用域</h3><p>变量作用域指定了变量定义的位置。</p><p>程序中变量的可用性由变量作用域决定。</p><p>TypeScript 有以下几种作用域：</p><ul><li><strong>全局作用域</strong> ：  全局变量定义在程序结构的外部，它可以在你代码的任何位置使用。</li><li><strong>类作用域</strong>  ：    这个变量也可以称为 字段。类变量声明在一个类里头，但在类的方法外面。 该变量可以通过类的对象来访问。类变量也可以是静态的，静态的变量可以通过类名直接访问。</li><li><strong>局部作用域</strong> ：   局部变量，局部变量只能在声明它的一个代码块（如：方法）中使用。</li></ul><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global_num = <span class="number">12</span>          <span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Numbers</span> { </span><br><span class="line">   num_val = <span class="number">13</span>;             <span class="comment">// 实例变量</span></span><br><span class="line">   <span class="keyword">static</span> sval = <span class="number">10</span>;         <span class="comment">// 静态变量</span></span><br><span class="line">   </span><br><span class="line">   <span class="title function_">storeNum</span>():<span class="built_in">void</span> { </span><br><span class="line">      <span class="keyword">var</span> local_num = <span class="number">14</span>;    <span class="comment">// 局部变量</span></span><br><span class="line">   } </span><br><span class="line">} </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span>全局变量为: <span class="string">""</span>+global_num)  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Numbers</span>.<span class="property">sval</span>)   <span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Numbers</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">""</span>实例变量: <span class="string">""</span>+obj.<span class="property">num_val</span>)</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript函数</title>
      <link href="/2022/01/01/typescript-han-shu/"/>
      <url>/2022/01/01/typescript-han-shu/</url>
      
        <content type="html"><![CDATA[<h1><strong>TypeScript函数</strong></h1><p><strong>函数是一组一起执行一个任务的语句。</strong>**<br>**<strong>可以把代码划分到不同的函数中。但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function function_name():return_type { </span><br><span class="line"> &nbsp; &nbsp;// 语句</span><br><span class="line"> &nbsp; &nbsp;return value; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>return_type 是返回值的类型。</strong></li><li><strong>return 关键词后跟着要返回的结果。</strong></li><li><strong>一般情况下，一个函数只有一个 return 语句。</strong></li><li><strong>返回值的类型需要与函数定义的返回类型(return_type)一致。</strong></li></ul><h2 id="带参函数"><strong>带参函数</strong></h2><p><strong>在调用函数时，您可以向其传递值，这些值被称为参数。</strong>**<br><strong><strong>这些参数可以在函数中使用。</strong></strong><br>**<strong>您可以向函数发送多个参数，每个参数使用逗号 , 分隔：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function func_name( param1 [:datatype], param2 [:datatype]) { &nbsp; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//示例</span><br><span class="line">function add(x: number, y: number): number {</span><br><span class="line"> &nbsp; &nbsp;return x + y;</span><br><span class="line">}</span><br><span class="line">console.log(add(1,2))</span><br></pre></td></tr></tbody></table></figure><h3 id="可选参数"><strong>可选参数</strong></h3><p><strong>在 TypeScript 函数里，如果我们定义了参数，则我们必须传入这些参数，除非将这些参数设置为可选，可选参数使用问号标识 ？。</strong>**<br>**<strong>实例</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string, lastName?: string) {</span><br><span class="line"> &nbsp; &nbsp;if (lastName)</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;return firstName + "" "" + lastName;</span><br><span class="line"> &nbsp; &nbsp;else</span><br><span class="line"> &nbsp; &nbsp; &nbsp; &nbsp;return firstName;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">let result1 = buildName(""Bob""); &nbsp;// 正确</span><br><span class="line">let result2 = buildName(""Bob"", ""Adams"", ""Sr.""); &nbsp;// 错误，参数太多了</span><br><span class="line">let result3 = buildName(""Bob"", ""Adams""); &nbsp;// 正确</span><br></pre></td></tr></tbody></table></figure><h3 id="默认参数"><strong>默认参数</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function function_name(param1[:type],param2[:type] = default_value) { </span><br><span class="line">}</span><br><span class="line">//示例</span><br><span class="line">function calculate_discount(price, rate) {</span><br><span class="line"> &nbsp; &nbsp;if (rate === void 0) { rate = 0.50; }</span><br><span class="line"> &nbsp; &nbsp;var discount = price * rate;</span><br><span class="line"> &nbsp; &nbsp;console.log(""计算结果: "", discount);</span><br><span class="line">}</span><br><span class="line">calculate_discount(1000);</span><br><span class="line">calculate_discount(1000, 0.30);</span><br></pre></td></tr></tbody></table></figure><h3 id="剩余参数（可变长度参数"><strong>剩余参数（可变长度参数)</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string, ...restOfName: string[]) {</span><br><span class="line"> &nbsp; &nbsp;return firstName + "" "" + restOfName.join("" "");</span><br><span class="line">}</span><br><span class="line"> &nbsp;</span><br><span class="line">let employeeName = buildName(""Joseph"", ""Samuel"", ""Lucas"", ""MacKinzie"");</span><br></pre></td></tr></tbody></table></figure><h3 id="匿名函数"><strong>匿名函数</strong></h3><p><strong>匿名函数是一个没有函数名的函数。</strong>**<br><strong><strong>匿名函数在程序运行时动态声明，除了没有函数名外，其他的与标准函数一样。</strong></strong><br>**<strong>我们可以将匿名函数赋值给一个变量，这种表达式就成为函数表达式。</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var res = function([arguments]){...}</span><br><span class="line">//示例 不带参数的匿名函数</span><br><span class="line">var msg = function() { </span><br><span class="line"> &nbsp; &nbsp;return ""hello world""; &nbsp;</span><br><span class="line">} </span><br><span class="line">console.log(msg())</span><br><span class="line"></span><br><span class="line">//带参数的匿名函数</span><br><span class="line">var res = function(a:number,b:number) { </span><br><span class="line"> &nbsp; &nbsp;return a*b; &nbsp;</span><br><span class="line">}; </span><br><span class="line">console.log(res(12,2))</span><br></pre></td></tr></tbody></table></figure><h3 id="匿名函数自调用"><strong>匿名函数自调用</strong></h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function () { </span><br><span class="line"> &nbsp; &nbsp;var x = ""Hello!!""; &nbsp; </span><br><span class="line"> &nbsp; &nbsp;console.log(x) &nbsp; &nbsp; </span><br><span class="line"> })()</span><br></pre></td></tr></tbody></table></figure><h3 id="构造函数"><strong>构造函数</strong></h3><p>** TypeScript 也支持使用 JavaScript 内置的构造函数 Function() 来定义函数：**</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> var res = new Function ([arg1[, arg2[, ...argN]],] functionBody)</span><br><span class="line"> //参数说明</span><br><span class="line"> //arg1, arg2, ... argN：参数列表。</span><br><span class="line"> //functionBody：一个含有包括函数定义的 JavaScript 语句的字符串。</span><br><span class="line"> </span><br><span class="line"> //示例</span><br><span class="line">var myFunction = new Function(""a"", ""b"", ""return a * b""); </span><br><span class="line">var x = myFunction(4, 3); </span><br><span class="line">console.log(x);</span><br></pre></td></tr></tbody></table></figure><h3 id="递归函数"><strong>递归函数</strong></h3><p><strong>递归函数即在函数内调用函数本身</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//示例</span><br><span class="line">function factorial(number) {</span><br><span class="line">    if (number &lt;= 0) {         // 停止执行</span><br><span class="line">        return 1; </span><br><span class="line">    } else {   </span><br><span class="line">        return (number * factorial(number - 1));     // 调用自身</span><br><span class="line">    } </span><br><span class="line">}; </span><br><span class="line">console.log(factorial(6));      // 输出 720</span><br></pre></td></tr></tbody></table></figure><h3 id="Lambada函数"><strong>Lambada函数</strong></h3><p><strong>Lambada函数也称之为箭头函数</strong>**<br>**<strong>箭头函数表达式的语法比函数表达式更短</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//语法</span><br><span class="line">( [param1, parma2,…param n] )=&gt;statement;</span><br><span class="line"></span><br><span class="line">//示例</span><br><span class="line">var foo = (x:number) =&gt;10+x</span><br><span class="line">console.log(foo(100))</span><br></pre></td></tr></tbody></table></figure><h3 id="函数重载"><strong>函数重载</strong></h3><p><strong>重载是方法名字相同，而参数不同，返回类型可以相同也可以不同。</strong>**<br>**<strong>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TypeScript</span><br><span class="line">function disp(s1:string):void; </span><br><span class="line">function disp(n1:number,s1:string):void; </span><br><span class="line"> </span><br><span class="line">function disp(x:any,y?:any):void { </span><br><span class="line">    console.log(x); </span><br><span class="line">    console.log(y); </span><br><span class="line">} </span><br><span class="line">disp(""abc"") </span><br><span class="line">disp(1,""xyz"");</span><br></pre></td></tr></tbody></table></figure><h3 id="元组"><strong>元组</strong></h3><p><strong>数组中元素的数据类型都一般是相同的（any[] 类型的数组可以不同），如果存储的元素数据类型不同，则需要使用元组。</strong>**<br>**<strong>元组中允许存储不同类型的元素，元组可以作为参数传递给函数。</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建元组</span><br><span class="line">var tuple_name = [value1,value2,value3...]</span><br><span class="line"></span><br><span class="line">//示例</span><br><span class="line">var mytuple = [10,""tom""]</span><br></pre></td></tr></tbody></table></figure><h4 id="元组运算"><strong>元组运算</strong></h4><ul><li><strong>push() 向元组添加元素，添加在最后面</strong></li><li><strong>pop()从元组中移除元素（最后一个),并返回移除的元素</strong></li></ul><h4 id="更新元组"><strong>更新元组</strong></h4><p><strong>元组是可变的，所以可对元组进行修改</strong>**<br>**<strong>根据指定的索引更新指定元素</strong></p><h4 id="解构元组"><strong>解构元组</strong></h4><p><em><strong><strong>个人理解</strong></strong></em>** 类似于java的顺序取值**</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a =[10,""Runoob""] </span><br><span class="line">var [b,c] = a </span><br><span class="line">console.log( b )  </span><br><span class="line">console.log( c )</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装Nginx</title>
      <link href="/2022/01/01/linux-xia-bu-shu-nginx/"/>
      <url>/2022/01/01/linux-xia-bu-shu-nginx/</url>
      
        <content type="html"><![CDATA[<h1>Linux安装Nginx</h1><h2 id="安装所需环境">安装所需环境</h2><ol><li>安装gcc<br>gcc是linux下的编译器，它可以编译 C,C++,Ada,Object C和Java等语言</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></tbody></table></figure><p>如果没安装会提示命令找不到</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>pcre、pcre-devel安装<br>pcre是一个perl库，包括perl兼容的正则表达式库，nginx的http模块使用pcre来解析正则表达式，所以需要安装pcre库。</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>zlib安装<br>zlib库提供了很多种压缩和解压缩方式nginx使用zlib对http包的内容进行gzip</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>安装openssl<br>openssl是web安全通信的基石，没有openssl，可以说我们的信息都是在裸奔</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></tbody></table></figure><h2 id="安装nginx">安装nginx</h2><ol><li>下载nginx安装包</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.18.0.tar.gz</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>把压缩包解压到/usr/local</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.18.0.tar.gz</span><br><span class="line">mv nginx-1.18.0 /usr/local/</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>切换到解压目录</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx-1.18.0</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>切换到安装目录</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>配置nginx的配置文件nginx.conf</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim conf/nginx.conf</span><br></pre></td></tr></tbody></table></figure><p>为了不污染主配置文件，添加include vhost/*.conf;</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http{</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">include  vhost/*.conf;</span><br><span class="line">....</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="6"><li>启动nginx服务<br>切换到目录/usr/local/nginx/sbin下</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx</span><br></pre></td></tr></tbody></table></figure><ol start="7"><li>查看nginx服务是否成功启动</li><li>设置nginx开机自启动</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim  /etc/init.d/nginx </span><br></pre></td></tr></tbody></table></figure><p>内容如下：</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /bin/bash</span></span><br><span class="line"><span class="comment"># chkconfig: - 85 15</span></span><br><span class="line"><span class="attr">PATH</span>=<span class="string">/usr/local/nginx       ###这里是你安装的路径，替换成自己安装的路径</span></span><br><span class="line"><span class="attr">DESC</span>=<span class="string">""nginx daemon""</span></span><br><span class="line"><span class="attr">NAME</span>=<span class="string">nginx</span></span><br><span class="line"><span class="attr">DAEMON</span>=<span class="string">$PATH/sbin/$NAME</span></span><br><span class="line"><span class="attr">CONFIGFILE</span>=<span class="string">$PATH/conf/$NAME.conf</span></span><br><span class="line"><span class="attr">PIDFILE</span>=<span class="string">$PATH/logs/$NAME.pid</span></span><br><span class="line"><span class="attr">SCRIPTNAME</span>=<span class="string">/etc/init.d/$NAME</span></span><br><span class="line"><span class="attr">set</span> <span class="string">-e</span></span><br><span class="line"><span class="attr">[</span> <span class="string">-x ""$DAEMON"" ] || exit 0</span></span><br><span class="line"><span class="attr">do_start()</span> <span class="string">{</span></span><br><span class="line"><span class="attr">$DAEMON</span> <span class="string">-c $CONFIGFILE || echo -n ""nginx already running""</span></span><br><span class="line"><span class="attr">}</span></span><br><span class="line"><span class="attr">do_stop()</span> <span class="string">{</span></span><br><span class="line"><span class="attr">$DAEMON</span> <span class="string">-s stop || echo -n ""nginx not running""</span></span><br><span class="line"><span class="attr">}</span></span><br><span class="line"><span class="attr">do_reload()</span> <span class="string">{</span></span><br><span class="line"><span class="attr">$DAEMON</span> <span class="string">-s reload || echo -n ""nginx can't reload""</span></span><br><span class="line"><span class="attr">}</span></span><br><span class="line"><span class="attr">case</span> <span class="string">""$1"" in</span></span><br><span class="line"><span class="attr">start)</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">-n ""Starting $DESC: $NAME""</span></span><br><span class="line"><span class="attr">do_start</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">"".""</span></span><br><span class="line"><span class="attr">;;</span></span><br><span class="line"><span class="attr">stop)</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">-n ""Stopping $DESC: $NAME""</span></span><br><span class="line"><span class="attr">do_stop</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">"".""</span></span><br><span class="line"><span class="attr">;;</span></span><br><span class="line"><span class="attr">reload|graceful)</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">-n ""Reloading $DESC configuration...""</span></span><br><span class="line"><span class="attr">do_reload</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">"".""</span></span><br><span class="line"><span class="attr">;;</span></span><br><span class="line"><span class="attr">restart)</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">-n ""Restarting $DESC: $NAME""</span></span><br><span class="line"><span class="attr">do_stop</span></span><br><span class="line"><span class="attr">do_start</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">"".""</span></span><br><span class="line"><span class="attr">;;</span></span><br><span class="line"><span class="attr">*)</span></span><br><span class="line"><span class="attr">echo</span> <span class="string">""Usage: $SCRIPTNAME {start|stop|reload|restart}"" &gt;&amp;2</span></span><br><span class="line"><span class="attr">exit</span> <span class="string">3</span></span><br><span class="line"><span class="attr">;;</span></span><br><span class="line"><span class="attr">esac</span></span><br><span class="line"><span class="attr">exit</span> <span class="string">0</span></span><br></pre></td></tr></tbody></table></figure><ol start="9"><li>加入系统设置开机自启动</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/rc.d/init.d/nginx #（设置可执行权限）</span><br><span class="line"></span><br><span class="line">chkconfig --add nginx #（添加系统服务）</span><br><span class="line"></span><br><span class="line">chkconfig --level 35 nginx on #（开机自启动）</span><br></pre></td></tr></tbody></table></figure><p>可以使用</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl   start nginx  #启动 </span><br><span class="line">systemctl   stop nginx   #关闭</span><br></pre></td></tr></tbody></table></figure><p>nginx.conf说明</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attr">worker_processes</span>  <span class="string">1; #工作进程：数目。根据硬件调整，通常等于cpu数量或者2倍cpu数量。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">#错误日志存放路径</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid; # nginx进程pid存放路径</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="attr">events</span> <span class="string">{</span></span><br><span class="line">    <span class="attr">worker_connections</span>  <span class="string">1024; # 工作进程的最大连接数量</span></span><br><span class="line"><span class="attr">}</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="attr">http</span> <span class="string">{</span></span><br><span class="line">    <span class="attr">include</span>       <span class="string">mime.types; #指定mime类型，由mime.type来定义</span></span><br><span class="line">    <span class="attr">default_type</span>  <span class="string">application/octet-stream;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    # 日志格式设置</span></span><br><span class="line"><span class="comment">    #log_format  main  '$remote_addr - $remote_user [$time_local] ""$request"" '</span></span><br><span class="line"><span class="comment">    #                  '$status $body_bytes_sent ""$http_referer"" '</span></span><br><span class="line"><span class="comment">    #                  '""$http_user_agent"" ""$http_x_forwarded_for""';</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #access_log  logs/access.log  main; #用log_format指令设置日志格式后，需要用access_log来指定日志文件存放路径</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">sendfile</span>        <span class="string">on; #指定nginx是否调用sendfile函数来输出文件，对于普通应用，必须设置on。</span></span><br><span class="line"><span class="attr">如果用来进行下载等应用磁盘io重负载应用，可设着off，以平衡磁盘与网络io处理速度，降低系统uptime。</span></span><br><span class="line"><span class="comment">    #tcp_nopush     on; #此选项允许或禁止使用socket的TCP_CORK的选项，此选项仅在sendfile的时候使用</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #keepalive_timeout  0;  #keepalive超时时间</span></span><br><span class="line">    <span class="attr">keepalive_timeout</span>  <span class="string">65;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #gzip  on; #开启gzip压缩服务</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #虚拟主机</span></span><br><span class="line">    <span class="attr">server</span> <span class="string">{</span></span><br><span class="line">        <span class="attr">listen</span>       <span class="string">80;  #配置监听端口号</span></span><br><span class="line">        <span class="attr">server_name</span>  <span class="string">localhost; #配置访问域名，域名可以有多个，用空格隔开</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">        #charset koi8-r; #字符集设置</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">        #access_log  logs/host.access.log  main;</span></span><br><span class="line"> </span><br><span class="line">        <span class="attr">location</span> <span class="string">/ {</span></span><br><span class="line">            <span class="attr">root</span>   <span class="string">html;</span></span><br><span class="line">            <span class="attr">index</span>  <span class="string">index.html index.htm;</span></span><br><span class="line">        <span class="attr">}</span></span><br><span class="line"><span class="comment">        #错误跳转页</span></span><br><span class="line"><span class="comment">        #error_page  404              /404.html; </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">        # redirect server error pages to the static page /50x.html</span></span><br><span class="line"><span class="comment">        #</span></span><br><span class="line">        <span class="attr">error_page</span>   <span class="string">500 502 503 504  /50x.html;</span></span><br><span class="line">        <span class="attr">location</span> = <span class="string">/50x.html {</span></span><br><span class="line">            <span class="attr">root</span>   <span class="string">html;</span></span><br><span class="line">        <span class="attr">}</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line"><span class="comment">        #</span></span><br><span class="line"><span class="comment">        #location ~ \.php$ {</span></span><br><span class="line"><span class="comment">        #    proxy_pass   http://127.0.0.1;</span></span><br><span class="line"><span class="comment">        #}</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line"><span class="comment">        #</span></span><br><span class="line"><span class="comment">        #location ~ \.php$ { #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span></span><br><span class="line"><span class="comment">        #    root           html; #根目录</span></span><br><span class="line"><span class="comment">        #    fastcgi_pass   127.0.0.1:9000; #请求转向定义的服务器列表</span></span><br><span class="line"><span class="comment">        #    fastcgi_index  index.php; # 如果请求的Fastcgi_index URI是以 / 结束的, 该指令设置的文件会被附加到URI的后面并保存在变量$fastcig_script_name中</span></span><br><span class="line"><span class="comment">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line"><span class="comment">        #    include        fastcgi_params;</span></span><br><span class="line"><span class="comment">        #}</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">        # deny access to .htaccess files, if Apache's document root</span></span><br><span class="line"><span class="comment">        # concurs with nginx's one</span></span><br><span class="line"><span class="comment">        #</span></span><br><span class="line"><span class="comment">        #location ~ /\.ht {</span></span><br><span class="line"><span class="comment">        #    deny  all;</span></span><br><span class="line"><span class="comment">        #}</span></span><br><span class="line">    <span class="attr">}</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    # another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class="line"><span class="comment">    #</span></span><br><span class="line"><span class="comment">    #server {</span></span><br><span class="line"><span class="comment">    #    listen       8000;</span></span><br><span class="line"><span class="comment">    #    listen       somename:8080;</span></span><br><span class="line"><span class="comment">    #    server_name  somename  alias  another.alias;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #    location / {</span></span><br><span class="line"><span class="comment">    #        root   html;</span></span><br><span class="line"><span class="comment">    #        index  index.html index.htm;</span></span><br><span class="line"><span class="comment">    #    }</span></span><br><span class="line"><span class="comment">    #}</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    # HTTPS server</span></span><br><span class="line"><span class="comment">    #</span></span><br><span class="line"><span class="comment">    #server {</span></span><br><span class="line"><span class="comment">    #    listen       443 ssl;  #监听端口</span></span><br><span class="line"><span class="comment">    #    server_name  localhost; #域名</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #    ssl_certificate      cert.pem; #证书位置</span></span><br><span class="line"><span class="comment">    #    ssl_certificate_key  cert.key; #私钥位置</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line"><span class="comment">    #    ssl_session_timeout  5m; </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #    ssl_ciphers  HIGH:!aNULL:!MD5; #密码加密方式</span></span><br><span class="line"><span class="comment">    #    ssl_prefer_server_ciphers  on; # ssl_prefer_server_ciphers  on; #</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    #    location / {</span></span><br><span class="line"><span class="comment">    #        root   html;</span></span><br><span class="line"><span class="comment">    #        index  index.html index.htm;</span></span><br><span class="line"><span class="comment">    #    }</span></span><br><span class="line"><span class="comment">    #}</span></span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 环境搭建 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL安装</title>
      <link href="/2022/01/01/mysql-an-zhuang/"/>
      <url>/2022/01/01/mysql-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1>MySQL安装</h1><h2 id="MySQL在线下载安装">MySQL在线下载安装</h2><p>注：需要连接互联网，在线mysql的安装包，5.6的版本大约86M</p><ol><li><p>查看CentOS是否自带的MySQL，如果已经安装需要卸载。如果没有找到，则表示没有安装。</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></tbody></table></figure></li><li><p>在线获取CentOS7的mysql的rpm安装文件，直接执行如下命令</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这条语句只是下载了一个rpm文件，25K大小</p></blockquote></li><li><p>执行安装命令</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql80-community-release-el7-1.noarch.rpm</span><br></pre></td></tr></tbody></table></figure></li><li><p>得到两个配置文件，在/etc/yum.repos.d目录下。</p><ul><li>mysql-community.repo用于指定下载哪个版本的安装包</li><li>mysql-community-source.repo用于指定下载哪个版本的源码</li></ul></li><li><p>修改MySQL的下载配置文件</p><ul><li>vim /etc/yum.repos.d/mysql-community.repo</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Enable to use MySQL 5.6</span><br><span class="line">[mysql56-community]</span><br><span class="line">name=MySQL 5.6 Community Server</span><br><span class="line">baseurl=http://repo.mysq.com/yum/mysql-5.6-community/el/7/$baseurl/</span><br><span class="line"># 设置为1，表示下载</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[mysql80-community]</span><br><span class="line">name=MySQL 8.0 Community Server</span><br><span class="line">baseurl=http://repo.mysq.com/yum/mysql-8.0-community/el/7/$baseurl/</span><br><span class="line"># 设置为0，表示不下载</span><br><span class="line">enabled=0</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql</span><br></pre></td></tr></tbody></table></figure></li><li><p>在当前目录/etc/yum.repos.d下执行下面的命令，开始在线下载：客户端，服务器端，开发的工具包。</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mysql-community-client mysql-community-server mysql-community-devel</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这里需要比较长的时间，要从互联网上下载86M左右的内容</p></blockquote></li><li><p>使用rpm命令，可以查询到mysql已经安装好的包</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="修改mysql底层码表">修改mysql底层码表</h2><h3 id="问题">问题</h3><p>由于mysql软件底层码表使用的不是utf-8，导致执行sql语句中文乱码。需要设置客户端和服务器端的编码为utf-8</p><h3 id="解决方案">解决方案</h3><ol><li><p>修改mysql的配置文件</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> Linux命令</span><br><span class="line">vim /etc/my.cnf</span><br></pre></td></tr></tbody></table></figure></li><li><p>在mysqld条目下增加以下配置，指定服务器的字符集为utf-8</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line">character-set-server=utf8 </span><br></pre></td></tr></tbody></table></figure></li><li><p>增加客户端的默认字符集的配置，指定为utf-8，将下面的配置放到文件的结尾处</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line"></span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></tbody></table></figure></li><li><p>文件保存退出后，重启mysql服务</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="启动MySQL服务并登录">启动MySQL服务并登录</h2><ol><li><p>启动mysql的服务</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> Linux命令</span><br><span class="line">systemctl start mysqld</span><br></pre></td></tr></tbody></table></figure></li><li><p>将mysql加到系统服务中并设置开机启动</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> Linux命令</span><br><span class="line">systemctl enable mysqld</span><br></pre></td></tr></tbody></table></figure></li><li><p>登录mysql，root用户默认没有密码</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> Linux命令</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></tbody></table></figure></li><li><p>在mysql中修改自己的密码</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> MySQL命令</span><br><span class="line">set password = password('密码'); </span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="设置远程访问权限">设置远程访问权限</h2><blockquote><p>开启mysql的远程登录权限，默认情况下mysql为安全起见，不支持远程登录mysql，所以需要设置开启，并且刷新权限缓存。</p></blockquote><ol><li><p>远程登录mysql的权限登录mysql后输入如下命令</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> MySQL命令</span><br><span class="line">grant all privileges on *.* to 'root'@'<span class="comment">%' identified by '自己设置密码';</span></span><br><span class="line">flush privileges;</span><br></pre></td></tr></tbody></table></figure></li><li><p>开放Linux的对外访问的端口3306</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> Linux命令</span><br><span class="line"><span class="params">#</span>开放3306端口</span><br><span class="line">/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="params">#</span>开放的端口永久保存到防火墙</span><br><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="params">#</span>重启防火墙</span><br><span class="line">systemctl restart firewalld</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="客户端Windows连接MySQL">客户端Windows连接MySQL</h2><p>在本地Windows系统使用Navicat Premium软件连接虚拟机中的Linux系统安装的MySQL</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> Linux </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux安装redis</title>
      <link href="/2022/01/01/linux-an-zhuang-redis/"/>
      <url>/2022/01/01/linux-an-zhuang-redis/</url>
      
        <content type="html"><![CDATA[<h1>linux安装redis</h1><h2 id="一、进入redis官网寻找要下载的版本：https-redis-io">一、进入redis官网寻找要下载的版本：<a href="https://redis.io/">https://redis.io/</a></h2><p>将下载地址链接复制下来： <a href="http://download.redis.io/releases/redis-6.0.5.tar.gz">http://download.redis.io/releases/redis-6.0.5.tar.gz</a></p><h2 id="二、在线下载redis">二、在线下载redis</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">wget  http://download.redis.io/releases/redis-6.0.5.tar.gz</span><br></pre></td></tr></tbody></table></figure><p>下载完成之后解压安装包并执行安装测试</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar xzf redis-6.0.5.tar.gz</span><br><span class="line">cd redis-6.0.5</span><br><span class="line">make test</span><br></pre></td></tr></tbody></table></figure><p>如果出现</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh: cc: command not found </span><br></pre></td></tr></tbody></table></figure><p>则执行如下命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install gcc gcc-c++ libstdc++-devel </span><br><span class="line">make MALLOC=libc</span><br></pre></td></tr></tbody></table></figure><p>如果出现</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">server.c: 在函数‘iAmMaster’中: server.c:4964:1: 警告:在有返回值的函数中,控制流程到达函数尾 [-Wreturn-type]</span><br><span class="line">....</span><br></pre></td></tr></tbody></table></figure><p>则系统gcc版本太低<br>解决gcc版本过低问题<br>安装scl源</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br></pre></td></tr></tbody></table></figure><p>列出scl可用源</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list all --enablerepo='centos-sclo-rh'</span><br></pre></td></tr></tbody></table></figure><p>安装8版本的gcc、gcc-c++、gdb工具链（toolchian）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y devtoolset-8-toolchain</span><br><span class="line">scl enable devtoolset-8 bash</span><br><span class="line">gcc --version</span><br></pre></td></tr></tbody></table></figure><h2 id="三、安装Redis">三、安装Redis</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></tbody></table></figure><p>启动Redis</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></tbody></table></figure><p>如果报如下错误，则根据提示修改以下内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sysctl vm.overcommit_memory=1</span><br><span class="line">echo 511 &gt; /proc/sys/net/core/somaxconn</span><br><span class="line">echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line">redis-server</span><br></pre></td></tr></tbody></table></figure><h2 id="四、配置">四、配置</h2><p>修改安装目录下的redis.conf文件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/local/redis-6.0.5/redis.conf </span><br></pre></td></tr></tbody></table></figure><p>修改以下配置：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">bind</span> 127.0.0.1 <span class="comment"># 将这行代码注释，监听所有的ip地址，外网可以访问</span></span></span><br><span class="line">protected-mode no # 把yes改成no，允许外网访问</span><br><span class="line">daemonize yes # 把no改成yes，后台运行</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">找到如下行：<span class="comment">#requirepass foobared，并改为</span></span></span><br><span class="line">requirepass XXXXXX （其中XXXXXX就是要设置的密码）</span><br></pre></td></tr></tbody></table></figure><h2 id="五、启动或停止">五、启动或停止</h2><p>redis提供了服务端命令和客户端命令：</p><ul><li>redis-server 服务端命令，可以包含以下参数：<br>start 启动<br>stop 停止</li><li>redis-cli 客户端控制台，包含参数：<br>-h xxx 指定服务端地址，缺省值是127.0.0.1<br>-p xxx 指定服务端端口，缺省值是6379</li></ul><h2 id="六、设置开机启动">六、设置开机启动</h2><ol><li>输入命令，新建文件</li></ol><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/init.d/redis</span><br></pre></td></tr></tbody></table></figure><p>输入下面内容：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># chkconfig:   2345 90 10</span></span><br><span class="line"><span class="comment"># description:  Redis is a persistent key-value database</span></span><br><span class="line">PATH=/usr/local/bin:/sbin:/usr/bin:/bin</span><br><span class="line"></span><br><span class="line">REDISPORT=6379</span><br><span class="line">EXEC=/usr/local/bin/redis-server</span><br><span class="line">REDIS_CLI=/usr/local/bin/redis-cli</span><br><span class="line"></span><br><span class="line">PIDFILE=/var/run/redis.pid</span><br><span class="line"></span><br><span class="line">CONF=<span class="string">""</span>/usr/local/redis-6.0.5/redis.conf<span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">""</span><span class="variable">$1</span><span class="string">""</span> <span class="keyword">in</span>  </span><br><span class="line">    start)  </span><br><span class="line">        <span class="keyword">if</span> [ -f <span class="variable">$PIDFILE</span> ]  </span><br><span class="line">        <span class="keyword">then</span>  </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">""</span><span class="variable">$PIDFILE</span> exists, process is already running or crashed<span class="string">""</span>  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">""</span>Starting Redis server...<span class="string">""</span>  </span><br><span class="line">                <span class="variable">$EXEC</span> <span class="variable">$CONF</span>  </span><br><span class="line">        <span class="keyword">fi</span>  </span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">""</span>$?<span class="string">""</span>=<span class="string">""</span>0<span class="string">""</span> ]   </span><br><span class="line">        <span class="keyword">then</span>  </span><br><span class="line">              <span class="built_in">echo</span> <span class="string">""</span>Redis is running...<span class="string">""</span>  </span><br><span class="line">        <span class="keyword">fi</span>  </span><br><span class="line">        ;;  </span><br><span class="line">    stop)  </span><br><span class="line">        <span class="keyword">if</span> [ ! -f <span class="variable">$PIDFILE</span> ]  </span><br><span class="line">        <span class="keyword">then</span>  </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">""</span><span class="variable">$PIDFILE</span> does not exist, process is not running<span class="string">""</span>  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">                PID=$(<span class="built_in">cat</span> <span class="variable">$PIDFILE</span>)  </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">""</span>Stopping ...<span class="string">""</span>  </span><br><span class="line">                <span class="variable">$REDIS_CLI</span> -p <span class="variable">$REDISPORT</span> SHUTDOWN  </span><br><span class="line">                <span class="keyword">while</span> [ -x <span class="variable">${PIDFILE}</span> ]  </span><br><span class="line">               <span class="keyword">do</span>  </span><br><span class="line">                    <span class="built_in">echo</span> <span class="string">""</span>Waiting <span class="keyword">for</span> Redis to shutdown ...<span class="string">""</span>  </span><br><span class="line">                    <span class="built_in">sleep</span> 1  </span><br><span class="line">                <span class="keyword">done</span>  </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">""</span>Redis stopped<span class="string">""</span>  </span><br><span class="line">        <span class="keyword">fi</span>  </span><br><span class="line">        ;;  </span><br><span class="line">   restart|force-reload)  </span><br><span class="line">        <span class="variable">${0}</span> stop  </span><br><span class="line">        <span class="variable">${0}</span> start  </span><br><span class="line">        ;;  </span><br><span class="line">  *)  </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">""</span>Usage: /etc/init.d/redis {start|stop|restart|force-reload}<span class="string">""</span> &gt;&amp;2  </span><br><span class="line">        <span class="built_in">exit</span> 1  </span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>然后保存退出</p><p>注意：以下信息需要根据安装目录进行调整：</p><blockquote><p>EXEC=/usr/local/bin/redis-server # 执行脚本的地址</p><p>REDIS_CLI=/usr/local/bin/redis-cli # 客户端执行脚本的地址</p><p>PIDFILE=/var/run/redis.pid # 进程id文件地址</p><p>CONF=“”/usr/local/src/redis-3.0.2/redis.conf"" #配置文件地址</p></blockquote><ol start="2"><li>设置权限</li></ol><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> 755 /etc/init.d/redis</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>启动测试</li></ol><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/redis start</span><br></pre></td></tr></tbody></table></figure><p>启动成功会提示如下信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Starting Redis server...</span><br><span class="line">Redis is running...</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>设置开机自启动</li></ol><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chkconfig --add /etc/init.d/redis</span><br><span class="line">sudo chkconfig redis on</span><br></pre></td></tr></tbody></table></figure><p>"</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> Linux </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装JDK1.8</title>
      <link href="/2022/01/01/linux-an-zhuang-jdk1.8/"/>
      <url>/2022/01/01/linux-an-zhuang-jdk1.8/</url>
      
        <content type="html"><![CDATA[<h1>Linux安装JDK1.8</h1><h2 id="1、检查系统中的jdk版本">1、检查系统中的jdk版本</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></tbody></table></figure><h2 id="2、检测jdk安装包">2、检测jdk安装包</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java</span><br></pre></td></tr></tbody></table></figure><h2 id="3、卸载openjdk">3、卸载openjdk</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps xxxxxxx</span><br></pre></td></tr></tbody></table></figure><p>或者</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove *openjdk*</span><br></pre></td></tr></tbody></table></figure><h2 id="4、安装新的jdk">4、安装新的jdk</h2><p>首先到jdk官网上下载你想要的jdk版本。官网由于证书问题wget 不能直接下载，需要加忽略证书和请求头。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate --no-cookies --header ""Cookie: oraclelicense=accept-securebackup-cookie"" http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.rpm</span><br></pre></td></tr></tbody></table></figure><p>添加执行权限：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x jdk-8u131-linux-x64.rpm </span><br></pre></td></tr></tbody></table></figure><p>执行rpm进行安装</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh jdk-8u131-linux-x64.rpm</span><br></pre></td></tr></tbody></table></figure><p>查看JDK是否安装成功</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></tbody></table></figure><p>查看JDK的安装路径，（一般默认的路径：/usr/java/jdk1.8.0_131）<br>移动到/usr/local下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /usr/java /usr/loacl</span><br></pre></td></tr></tbody></table></figure><ol><li><p>配置jdk环境变量，打开/etc/profile配置文件，将下面配置拷贝进去。export命令用于将shell变量输出为环境变量。</p><p>注：在linux下以冒号分隔不同的路径，而windows下是分号。</p><p>注：引用变量在linux下是$变量名, 在windows下是%变量名%</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></tbody></table></figure></li></ol><ul><li><p>/etc/profile</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span>set java environment</span><br><span class="line">JAVA<span class="built_in">_</span>HOME=/usr/local/jdk1.8.0<span class="built_in">_</span>211</span><br><span class="line">CLASSPATH=.:<span class="built_in">$</span>JAVA<span class="built_in">_</span>HOME/lib</span><br><span class="line">PATH=<span class="built_in">$</span>JAVA<span class="built_in">_</span>HOME/bin:<span class="built_in">$</span>PATH</span><br><span class="line">export JAVA<span class="built_in">_</span>HOME CLASSPATH PATH</span><br></pre></td></tr></tbody></table></figure></li></ul><ol start="3"><li><p>重新加载/etc/profile配置文件，并测试</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></tbody></table></figure></li><li><p>判断JDK是否安装成功</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">javac -version</span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> Linux </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
